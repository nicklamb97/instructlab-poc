[
    {
        "instruction": "How do you specify a delimiter in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "To specify a delimiter for the copy into or copy from statement, use the FIELD TERMINATOR clause. The syntax is:\n```\nFIELD TERMINATOR = character_literal;\n```\nReplace `character_literal` with the desired delimiter value (single quote not required). This clause sets the delimiter for\nthe entire statement. If no delimiter is specified, Actian defaults to using the comma or semicolon as the delimiter.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a simple example of how you would use Actian 4GL SQL COPY statements in your code.",
        "input": "",
        "output": "Here is an example of using Actian 4GL SQL COPY statements:\n```sql\n-- Import all records from the 'employees' table into a new file called 'staff_list'.\nCOPY staff_list (\n    first_name, last_name, title, department)\nFROM employees;\n\n-- Export the 'orders' table to an external text file.\nCOPY orders TO 'order_data';\n```\nThese statements demonstrate the simplicity and versatility of Actian 4GL SQL COPY statements in handling data transfers between different systems or within the same database.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What are the restrictions on using Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "When using Actian 4GL SQL COPY statements, keep in mind that they have limitations such as:\n- They cannot modify existing data in tables or files.\n- They can only copy columns with compatible data types between systems.\n- You must specify the correct syntax for your particular situation (e.g., case sensitivity).",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a statement that describes how you would use the varchar(n) format with a length specifier in your code.",
        "input": "",
        "output": "You can set the length of a variable-length string field using the varchar(n) format, where n is an integer value representing the desired maximum number of characters in the field. This format allows you to define the size of the field exactly, preventing overflows or underflows for that specific column in your table. For example, in the following code snippet:\n```\ncreate table author (\n  name varchar(50),\n  birthdate date not null,\n  address text(100) null,\n  phone number(10) primary key;\n```\nHere, we define the 'name' column as a variable-length string with a maximum length of 50 characters. The other fields in this example are also defined using their appropriate formats:\n\u2022 \u2018birthdate\u2019 is a date data type with no allowance for null values (not null specification),\n\u2022 \u2018address\u2019 is a text field that can contain up to 100 characters, and\n\u2022 \u2018phone\u2019 is a numeric field representing phone numbers, set as the primary key for this table.\nYou can then use these fields in your code, such as setting values, performing calculations, or displaying them on forms or reports. The length specifier ensures that the variable-length string has no more than the specified number of characters, avoiding potential issues like overflows or underflows that could occur with other formats (like char(n) or text(n)).",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a statement that demonstrates how you would use the X delimiter in your code.",
        "input": "",
        "output": "You can use the 'X' character as a delimiter in your code to separate fields or mark the end of records in data files. This delimiter is useful when designing custom formats for importing and exporting data between Actian databases and other systems. For example, in the following code snippet:\n```\ncreate table customer (\n  first_name char(20),\n  last_name varchar(40) not null,\n  address text(60) null,\n  phone number(10) primary key;\n```\nHere, we define the 'first_name' column as a fixed-length string with a maximum length of 20 characters. The other fields in this example are also defined using their appropriate formats:\n\u2022 \u2018last_name\u2019 is a variable-length string with no allowance for null values (not null specification),\n\u2022 \u2018address\u2019 is a text field that can contain up to 60 characters, and\n\u2022 \u2018phone\u2019 is a numeric field representing phone numbers, set as the primary key for this table.\nYou can then use these fields in your code, such as setting values, performing calculations, or displaying them on forms or reports. The 'X' delimiter is used here to separate the columns and mark the end of records in the data file.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What is the difference between insert statement and copy statement in Actian 4GL?",
        "input": "",
        "output": "The insert statement adds a new record to an existing table, while the copy statement copies data from one table into another.\nBoth statements are used for similar purposes, such as loading data into a new database or updating existing records in an existing\ndatabase. However, they differ in how they handle the data they operate on and what happens to the original data after the\nstatement is executed.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What are restrictions when using copy statement in Actian 4GL?",
        "input": "",
        "output": "The copy statement cannot be used to add data to a view, index, or system catalog. It also ignores any integrity constraints defined against the table when copying from a data file to it. In addition, it does not fire rules defined against the table during the copy process. These restrictions ensure that the copy statement is used for its intended purpose and does not affect other parts of the Actian environment.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Explain how to use the 'NOT NULL' clause in an Actian 4GL SQL COPY statement.",
        "input": "",
        "output": "The `NOT NULL` clause can be used in an Actian 4GL SQL COPY statement to:\n- Specify that only non-nullable columns should be copied from or into the specified table or data file.\nOr\n- Define a default value for any nullable columns in the table or data file.\nThe `NOT NULL` clause is optional and can be omitted if no special handling is required for nullable columns.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe the syntax and usage of the 'ERROR ON' clause in an Actian 4GL SQL COPY statement.",
        "input": "",
        "output": "The `ERROR ON` clause can be used in an Actian 4GL SQL COPY statement to:\n- Specify a custom error message that should be displayed when an invalid value is encountered during data transfer.\nOr\n- Define the maximum number of errors allowed before terminating the operation.\nThe `ERROR ON` clause is also optional and can be omitted if no special handling is required for invalid data.\nWhen used with the `TERMINATE` keyword, it instructs Ingres to abort the operation immediately upon encountering an error that exceeds the specified error count.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How do you create a new table in Actian with Actian 4GL SQL statements?",
        "input": "",
        "output": "To create a new table in Actian, use the `CREATE TABLE` statement as follows:\n```\nCREATE TABLE name (columns);\n```\nReplace `name` with the desired name for your table and define the column list after the parentheses. For example:\n```\nCREATE TABLE customers (\n    id INTEGER NOT NULL,\n    first_name CHAR(20) NOT NULL,\n    last_name CHAR(20) NOT NULL,\n    email CHAR(50) NOT NULL UNIQUE,\n    phone NUMERIC(10) NOT NULL,\n    address CHAR(75) NOT NULL,\n    city CHAR(30) NOT NULL,\n    state CHAR(2) NOT NULL,\n    zip_code CHAR(6) NOT NULL,\n    created_at TIMESTAMP(4) DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP(4) DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (id),\n    UNIQUE INDEX email (email ASCENDING));\n```\nIn this example, we define the primary key and a unique index for email. The other columns are defined as not nullable.\nYou can also add any default values you want to the column definitions. For instance, here we set the `created_at`\nand `updated_at` timestamp fields to their current system time.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How do you delete a record from an Actian database using Actian 4GL SQL statements?",
        "input": "",
        "output": "To remove a row from an Actian database table, use the `DELETE FROM` statement as follows:\n```\nDELETE FROM table_name;\n```\nReplace `table_name` with the name of the Actian database table containing records to be deleted. No additional\nkeywords or clauses are required for this simple operation.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What are some common errors that can occur when using Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "Common errors include:\n- Syntax errors due to incorrect usage of keywords or clauses.\n- Data type mismatches between the source and destination.\n- Memory allocation issues for sorting rows before inserting them into a table.\n- Locking conflicts when copying from a table into a file or vice versa.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How can you prevent parsing errors or data corruption when using Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "To avoid parsing errors and data corruption, follow these best practices:\n- Always use valid delimiters that are compatible with your data type.\n- Specify the correct file format for the statement (binary or text).\n- Check for any discrepancies between the source and destination before executing the copy operation.\n- Use error handling clauses like `ON ERROR` to manage potential errors gracefully.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe how to convert a string into an integer in an Actian 4GL program.",
        "input": "",
        "output": "To convert a string into an integer in your Actian 4GL program, use the `CAST` function as follows:\n```\nCAST(expression AS INTEGER);\n```\nReplace `expression` with the variable name or literal expression you want to convert. The `CAST` function can also be used\nwith a format specifier to define the desired data type and conversion rules. For example, the following converts the string '100' into an integer:\n```\nCAST('100' AS INTEGER);\n```\nWhen using the `CAST` function with a format specifier, you must enclose the format in parentheses after the keyword 'AS'. The format can be any of the Actian 4GL supported data types, including numeric (integer, floating point, or boolean), character (char or varchar), or date/time.\nThe `CAST` function can also be used to convert between different data types. For example, the following converts a char field into its underlying integer value:\n```\nCAST(name CHARACTER TO INTEGER);\n```\nIn this case, Ingres first reads the value of the name variable as a character string. Then it applies the specified conversion rules to convert that string into an integer. The resulting integer is then stored back into the name variable.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What are the syntax rules for defining columns in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "In Actian 4GL SQL COPY statements, you can define columns using the following syntax:\n- For simple variables, simply type the variable name followed by an equal sign (=) and the desired value.\n- For complex data types, use a dedicated function call with parameters specifying the data type and the value to be set.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How can you initialize the values of simple variables in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "In Actian 4GL SQL COPY statements, you can initialize simple variable values using one of these methods:\n- Setting them to null using the 'IS NULL' clause.\n- Assigning a default value with the 'DEFAULT' keyword.\n- Using a literal value for simple data types (e.g., integers or floating points).",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a statement that describes how you would use the row_estimate clause with an estimated number of rows in your code.",
        "input": "",
        "output": "You can specify the estimated number of rows to be copied from a file to a table during a bulk copy operation using the 'row\\_estimate' clause in your code. The DBMS Server uses this value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation, especially when dealing with large amounts of data:\n```sql\n-- Import all records from the 'customers' table into a new file called 'customer_database'.\nCOPY customer_database (\n    first_name, last_name, address)\nFROM customers;\n\n-- Export the 'orders' table to an external text file, estimating 10,000 rows.\nCOPY orders TO 'order_data' (\n    WITH ROW\\_ESTIMATE = 10000) ;\n```\nThese statements demonstrate how you can use Actian 4GL SQL COPY statements to handle large data sets efficiently and accurately in your code.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe the difference between a variable-length string and a fixed-length string in Actian 4GL.",
        "input": "",
        "output": "A variable-length string can have any length, up to the maximum row size configured for the database. It is not limited by a fixed number of characters. You can use it for fields that may contain large amounts of data, such as memo or text.\nA fixed-length string has a predetermined length, set when you declare it. Any characters beyond this length are discarded or padded with zeros. It is useful for fields that have a known size, such as small integers or enums.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe the syntax and usage of the 'C' format in an Actian 4GL SQL COPY statement.",
        "input": "",
        "output": "The 'C' format specifies a fixed-length string that can hold characters. It is similar to the char format, but it allows for more complex data types like pointers and structs. You can use it for fields with variable sizes, such as addresses or phone numbers.\nWhen writing data into a field of this format, Ingres fills in any remaining blanks with zeros. If necessary, it also converts control characters or tabs into spaces before storing them in memory.\nWhen reading values from a field of this format, Ingres skips over any leading or trailing blank characters. It also converts spaces back into their original control characters when needed during parsing.\nThe 'C' format supports escaping special characters like \\ with a backslash (\\). You can use it for fields that may contain sensitive information, such as passwords or credit card numbers.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Explain what happens when you try to copy more records than fit into the target field with Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "When trying to copy more records than fit into the target field with Actian 4GL SQL COPY statements, the following occurs:\n* If you are using a variable-length string type for your field, then Actian 4GL automatically truncates any excess data.\nOr\n* If you are using a fixed-length string type for your field, then Actian 4GL generates an error message and terminates the operation.\nFor example, when copying the 'C0' format into a text file, any control characters or tabs in the input are converted to spaces. Similarly, when reading data from an external text file, any control characters or tabs are also converted to spaces before being stored in memory.\nWhen specifying delimiters for variable-length strings, use the 5-character right-justified length specifier. For example:\n```sql\nCOPY staff_list (\n    first_name CHAR(20), last_name CHAR(30), title CHAR(10));\n```\nIn this example, the 'CHAR' keyword specifies that the field should be treated as a fixed-length string of the specified length. The length specifier follows it, which is 20 characters for 'first_name', 30 characters for 'last_name', and 10 characters for 'title'. When copying data into or out of the file, any control characters or tabs are padded with zeros before being stored in memory.\n* When using Actian 4GL with other systems or databases, it is important to understand how they handle delimiters and field names. For example:\n```sql\nCOPY customers TO 'customer_data';\n```\nIn this example, the 'TO' clause specifies the destination of the copy operation. The field names are also specified after the keyword 'CUSTOMER'. When copying data into or out of the file, any control characters or tabs are converted to spaces before being stored in memory.\n* Actian 4GL supports a wide range of data types, including numeric and character types. When working with these types, it is important to understand how they are represented in memory and when transferring between systems or databases. For example:\n```sql\nCOPY orders (\n    order_id INTEGER NOT NULL,\n    customer_id INTEGER NOT NULL,\n    product_code CHAR(10), quantity INTEGER",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How can you specify a particular column order when copying data into or out of an Actian database table?",
        "input": "",
        "output": "To specify the order of columns in an Actian database table for copy statements, use with row_estimate (see Row_estimate). For example:\n```\nCOPY t (col1=c20, col2=c30) INTO \u2018t.out\u2019 WITH (row_estimate = 50);\n```\nReplace `t` with the name of your Actian database table and set the desired number of rows to copy using `row_estimate`.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What are some common options used in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "Some common options include:\n\u2022 field length specifiers (such as size or precision) for setting the size of a column'\u2022 delimiters to separate fields and define the end of records\nin data files\n\u2022 encoding formats that control how data is stored and read from tables\n\u2022 indexing strategies for managing secondary indices on table columns\n\u2022 sort orders for organizing data in a specific order (ascending or descending)",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe the syntax for setting the initial value of a variable-length string field in Actian 4GL.",
        "input": "",
        "output": "You can set the initial value of a variable-length string field in Actian 4GL using the following syntax:\nfield = 'value';\nWhere 'field' is the name of the variable and 'value' is the desired initial value for that variable. You can also use literal constants, such as integers or Boolean values, instead of variable references. For example:\ntitle = 'Destry Destroy';\nCan be used to define a char field with the specified title. Similarly, you can use the null keyword to set the field's initial value to its default value:\ntitle = null;\nThis sets the 'title' variable to its default value of 'null'. You can also use the zero keyword to represent the integer zero for numeric fields.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How do you declare a fixed-length string field in Actian 4GL?",
        "input": "",
        "output": "You can declare a fixed-length string field in Actian 4GL using the following syntax:\nfield (n) = 'value';\nWhere 'field' is the name of the variable and 'n' is the desired length of the field. You can also use literal constants, such as integers or Boolean values, instead of variable references. For example:\nauthor (20) = 'Batman';\nDeclares an char field with 20 characters. The value 'Batman' is written into the field using the specified length. You can also use the null keyword to set the field's initial value to its default value:\nauthor (null) = null;\nThis sets the 'author' variable to its default value of 'null'. Similarly, you can use the zero keyword to represent the integer zero for numeric fields.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What is the purpose of the copy into clause in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "The 'copy into' clause in Actian 4GL SQL COPY statements specifies the destination table for the data being copied from a file. This allows you to perform operations such as inserting new rows into an existing table or updating existing rows with different values.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What is the default value of the row_estimate parameter in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "The default value of the row_estimate parameter in Actian 4GL SQL COPY statements is 0. This means that no memory is allocated for sorting rows before inserting them into the table.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What are dummy fields in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "Dummy fields in Actian 4GL SQL COPY statements are variables that represent the value of a column, not the actual data in it. They can be used for performing operations like setting or getting values from columns without having to specify them individually. For example, you can use a dummy field as the target of an assignment statement instead of specifying the exact column name.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe how you can use the 'NOT NULL' constraint in an Actian 4GL SQL COPY statement.",
        "input": "",
        "output": "The `NOT NULL` constraint can be used in an Actian 4GL SQL COPY statement to:\n- Ensure that null values are not inserted into the destination table for any columns specified as NOT NULL.\nOr\n- Specify a default value for the column if it contains a null value when copying from another table or file.\nThe `NOT NULL` constraint is optional and can be omitted if no special handling is required for null values in the destination table.\nWhen used with the 'TERMINATE' keyword, it instructs Ingres to abort the operation immediately upon encountering a null value that exceeds the specified error count.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe the differences between the 'CHARACTER SET' and 'BLOB' data types in Actian.",
        "input": "",
        "output": "The 'CHARACTER SET' data type represents text strings up to a maximum length of 255 characters (including any embedded control characters or tabs). It is typically used for storing names, descriptions, or other types of alphanumeric information.\nThe 'BLOB' data type represents binary data up to a maximum size of 64 KiB (32,768 bytes). It is generally used for storing images, audio files, or other types of multimedia content.\nBoth data types support the same set of features, such as indexing, sorting, and searching. However, they have different storage requirements: 'CHARACTER SET' requires less memory than 'BLOB', whereas 'BLOB' requires more than twice the amount of memory required by 'CHARACTER SET'.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe the syntax and usage of the 'INSERT INTO' clause in an Actian 4GL SQL COPY statement.",
        "input": "",
        "output": "The `INSERT INTO` clause can be used in an Actian 4GL SQL COPY statement to:\n- Specify a destination table for the data being copied.\nOr\n- Define any attributes of that table, such as primary keys or foreign keys.\nThe `INSERT INTO` clause is required when copying data into a new table or modifying existing records in an existing table. It also allows you to specify how you want Ingres to handle duplicate entries, such as overwriting them or inserting them into a separate index.\nWhen used with the `TERMINATE` keyword, it instructs Ingres to abort the operation immediately upon encountering an error that exceeds the specified error count.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe how to use the `NOT NULL` clause in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "The `NOT NULL` clause in Actian 4GL SQL COPY statements allows specifying that a value cannot be null or empty. It can also be used with a format specifier to define the desired data type and conversion rules for non-null values. For example, the following sets the value of a numeric field to zero:\n```\nNOT NULL;\n```\nWhen using the `NOT NULL` clause without a format specifier, Ingres assumes the default data type is integer. The `NOT NULL` function can also be used with a format specifier to define the desired data type and conversion rules for non-null values. For example, the following sets the value of a numeric field to zero:\n```\nCAST(0 AS INTEGER);\n```\nThe `CAST` function converts the literal '0' into an integer value before storing it into the field. The resulting integer is then stored back into the variable or literal expression you specified.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a statement that describes how to set the initial value of a field when creating it in an Actian 4GL SQL COPY statement.",
        "input": "",
        "output": "You can use the following syntax to specify the initial value for a field when creating it in an Actian 4GL SQL COPY statement:\nfield_name = expression;\nWhere 'field_name' is the name of the field being created, and 'expression' is any valid Actian expression that represents the desired initial value for the field. For example, you can set the default value of a char field to 'Hello World!' like this:\nname = 'Hello World!';\nOr you can use literals, functions, or operators to define the initial value for numeric or boolean fields. Here are some examples:\nage = 35;\nIs_active = TRUE;\nSalary = $100,000;",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a statement that describes how to read data from a field into an variable in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "You can use the following syntax to read the value of a field into an variable in Actian 4GL SQL COPY statements:\nvariable = field_name;\nWhere 'field_name' is the name of the field that contains the data you want to read into the variable. For example, you can read the first name of a person object into a string variable like this:\nname = people.first_name;\nOr you can use literals, functions, or operators with your code to define the variable and access the field data. Here are some examples:\ncolor = car.paint.color;\nQuantity = order_items.quantity;\nMax_speed = engine.max_speed;",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Describe how to use the 'BULK' keyword in an Actian 4GL SQL COPY statement for performing multiple inserts at once into a table.",
        "input": "",
        "output": "To perform several inserts concurrently into an Actian database table using the 'BULK' key phrase, follow these steps:\n1. Define the variable list containing all of the field names you want to include in your statement. For example:\n```\nVARIABLE (name, age, dept) = emp;\n```\n2. Use the 'BULK' keyword to indicate that you are working with a variable list instead of individual fields.\n3. Specify the table name after the variable declaration, followed by an opening parenthesis and the variable name:\n```\nINTO TABLE (employee) BULK = emp;\n```\n4. Terminate your statement with a semicolon (;). This tells Ingres that you have finished specifying all of the fields in your variable list, and it can now execute the statement.\nWhen using the 'BULK' keyword, remember that it is case-sensitive and must be spelled correctly for Actian to understand it. Additionally, no keywords or clauses are required when using this feature; just use it as shown here to perform multiple inserts at once into a table.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How do you read from a fixed-length string field into your program in Actian 4GL?",
        "input": "",
        "output": "You can read the value of a fixed-length string field into your program using the following syntax:\nfield (n) = <value>;\nWhere 'field' is the name of the variable and 'n' is the length of the field. The value is read from the specified length, starting at the first character of the field. You can also use literal constants instead of variables, such as integers or Boolean values, in place of the field name. For example:\nauthor (20) = 'Batman';\nReads the value 'Batman' from the char field with 20 characters. The length specifier '20' is used to specify the desired length of the field. Similarly, you can use the null keyword to read the default value of a variable or set it to its initial value:\nauthor (null) = null;\nThis sets the 'author' variable to its default value of 'null'. You can also use the zero keyword to represent the integer zero for numeric fields.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How do you write into a fixed-length string field in Actian 4GL?",
        "input": "",
        "output": "You can write the value of any type into a fixed-length string field using the following syntax:\nfield (n) = value;\nWhere 'field' is the name of the variable and 'n' is the desired length of the field. You can also use literal constants instead of variables, such as integers or Boolean values, in place of the field name. For example:\nauthors (20) = 'DC Comics';\nWrites the value 'DC Comics' into an char field with 20 characters. The length specifier '20' is used to specify the desired length of the field. Similarly, you can use the null keyword to set the field's initial value to its default value:\nauthors (null) = null;\nThis sets the 'authors' variable to its default value of 'null'. You can also use the zero keyword to represent the integer zero for numeric fields.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How can you use the 'WITH CLause' option with the 'COPY STATEMENT' to specify the error handling behavior for data conversion errors?",
        "input": "",
        "output": "You can set the on_error clause to either TERMINATE or CONTINUE to define how copy responds to errors that occur while converting between table format and file format. When on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message indicating how many warnings were issued and how many rows were successfully copied. Setting error_count specifies how many errors can occur before processing terminates. By default, copy terminates when an error occurs while converting between table format and file format.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a statement that demonstrates how you would use the X delimiter in your code when importing and exporting complex data types between Actian databases and other systems.",
        "input": "",
        "output": "You can use the 'X' character as a delimiter in your code to separate fields or mark the end of records in data files when importing and exporting complex data types between Actian databases and other systems. This delimiter is particularly useful when designing custom formats for importing and exporting complex data types, such as:\n\u2022 Objects with multiple attributes (e.g., customers),\n\u2022 Enumerated types (e.g., gender or color), or\n\u2022 Numeric values that require specific precision (e.g., money).\nFor example, in the following code snippet:\n```\ncreate table vehicle (\n  make char(20) not null,\n  model varchar(40) unique,\n  year numeric(4,2) primary key;\n```\nHere, we define the 'make' column as a fixed-length string with no allowance for null values. The other fields in this example are also defined using their appropriate formats:\n\u2022 \u2018model\u2019 is a variable-length string with unique values representing different vehicle makes and models, and\n\u2022 \u2018year\u2019 is a numeric field representing the vehicle\u2019s production year, set as the primary key for this table.\nYou can then use these fields in your code, such as setting values, performing calculations, or displaying them on forms or reports. The 'X' delimiter is used here to separate the columns and mark the end of records in the data file.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a statement that inserts the value of an integer variable into the specified field in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "You can use the following syntax to insert the value of an integer variable into a field in Actian 4GL SQL COPY statements:\nfield_name = variable;\nWhere 'field_name' is the name of the field that you want to update with the value from the integer variable. For example, you can set the color of a car object to red like this:\ncar.paint.color = 16711680;\nOr you can use literals, functions, or operators with your code to define the field and set its value. Here are some examples:\npeople.first_name = 'John';\nQuantity = 50;\nMax_speed = 130;",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "What should you consider when choosing delimiters in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "When selecting delimiters for Actian 4GL SQL COPY statements, it's important to avoid characters that may appear\nin data or padding within files. Incorrect delimiter selection can lead to parsing errors or data corruption. For example, if you choose a character as the delimiter and it appears in the data, the parser will not be able to distinguish between the field value and the delimiter. This can cause issues when trying to read or write data to/from the field. Similarly, if you use a numeric format for a field that contains non-numeric data, the database manager will attempt to convert the data to the appropriate format. This can result in errors or loss of data integrity.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "Write a statement that creates a new table with the specified name and columns in Actian 4GL SQL COPY statements.",
        "input": "",
        "output": "You can use the following syntax to create a new table with the specified name and columns in Actian 4GL SQL COPY statements:\ncreate table tablename (column1 type, column2 type, ...);\nWhere 'tablename' is the name of the new table you want to create, and the 'types' are the data types of the columns. For example, you can create a table with three integer fields like this:\ncreate table my_table (id integer, name varchar(50), address char(100));\nOr you can use literals, functions, or operators with your code to define the table and its columns. Here are some examples:\ncreate table people (id serial primary key, first_name varchar(50) not null, last_name varchar(50) not null);\ncreate index on people (first_name);",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    },
    {
        "instruction": "How do you remove all the rows from a table in Actian 4GL SQL COPY statements?",
        "input": "",
        "output": "You can use the following syntax to delete all the rows from a table in Actian 4GL SQL COPY statements:\ndelete from tablename;\nWhere 'tablename' is the name of the table you want to empty. For example, you can clear out all the data from an order\ntable like this:\ndelete from orders;\nOr you can use literals, functions, or operators with your code to define the table and remove its rows. Here are some examples:\ntruncate table people;\ndelete from customers where state = 'CA';",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->copy_statements",
        "task_description": "Explain the syntax and usage of Actian 4GL SQL COPY statements for data import and export, with focus on delimiters and advanced options.",
        "document": [
            "Copy Statement\nThe copy statement copies the contents of a table to a data file (copy into) or copies the contents of a file to a table (copy from). For more information on the copy statement, see Populating Tables in the Ingres Database Administrator Guide.\nThis statement has the following syntax:\ncopy [table] [schema.]table_name\n              ([column_name = format [with null [(value)]]\n              {, column_name = format [with null [(value)]]}])\n              into | from 'filename[, type]'\n              [with_clause];\nParameters--Copy Statement\nThis statement has the following parameters:\ntable_name\nSpecifies an existing table from which data is read or to which data is written.\ncolumn_name\nSpecifies the column from which data is read or to which data is written.\nformat\nSpecifies the format in which a value is stored in the file.\nfilename\nSpecifies the file from which data is read or to which data is written.\ntype\n(Optional) Specifies the file translation type (see Windows File Types for Copy): T or B.\nA space after the comma or at the end of the filename causes the name to be taken literally, rather than interpreting a filetype. If a filename ends in a space, Windows removes the trailing spaces so that they do not appear in the actual file name.\nwith_clause\nConsists of the word with, followed by a comma-separated list of one or more of the following items:\n\u2022on_error = TERMINATE | CONTINUE\n\u2022error_count = n\n\u2022rollback = ENABLED | DISABLED\n\u2022log = 'filename'\nThe following options are valid for bulk copy operations only. For details about these settings, see Modify Statement. The value specified for any of these options becomes the new setting for the table and overrides any previously made settings (either using the modify statement or during a previous copy operation).\n\u2022allocation = n\n\u2022extend = n\n\u2022fillfactor = n (ISAM, Hash, and Btree only)\n\u2022minpages = n (Hash only)\n\u2022maxpages = n (Hash only)\n\u2022leaffill = n (Btree only)\n\u2022nonleaffill = n (Btree only)\n\u2022row_estimate = n\nUnformatted Copying\nTo copy all rows of a table to a file with no conversion or formatting, omit the column list from the copy statement. This operation is referred to as an unformatted copy.\nFor example, to copy the entire employee table into the file, emp_name, issue the following statement:\ncopy table employee () into 'emp_name';\nParentheses must be included in the statement, even though no columns are listed. The resulting binary file contains data stored in column binary formats. To load data from a file that was created by an unformatted copy into, use an unformatted copy from.\nNote:  An unformatted copy (whether using copy, copydb, or unloaddb) is not portable across platforms due to the endianness of the binary data.\nFormatted Copying\nFormatted copying allows the type, number, and order of columns in the data file to differ from the table. By specifying a list of columns and their types in the copy statement, you instruct Ingres to perform a formatted copy. The copy statement list specifies the order and type of columns in the data file. Ingres uses the column names in the list to match up file data with the corresponding columns in the table.\nFor human readable text data files, the copy list formats will almost always be a character type: char, c, text, or less commonly varchar or byte. The copy statement converts (character) file data into table data types for copy from, or the reverse for copy into. The copy list may contain other types as well, such as integer or decimal, but these are binary types for special programming situations; they are not human readable types. Copy also supports a \"dummy\" type, used to skip input data (from) or insert fixed output text (into).\nIf some table columns are not listed in the copy list for a copy from, those columns are defaulted. (If they are defined in the table as not default, an error occurs.) If some table columns are not listed for a copy into, those table columns simply do not appear in the output data file.\nThe order of columns in the table need not match the order in the data file. Remember that the order of columns in the copy list reflects the order in the data file, not the order in the table. Additionally, a table column may be named more than once. (For copy from, if a column is named multiple times, the last occurrence in the copy list is the one that is stored into the table. Earlier occurrences undergo format conversion, but the result is discarded.)\nSpecial restriction: If the table includes one or more long columns (such as long varchar or long byte), columns cannot be reordered across any long column. For example, if the table contains (int a, int b, long varchar c), a copy statement could use the order (b,a,c); but a copy statement asking for (a,c,b) would be illegal (you cannot move column b to occur after the long column c).\nThe values in the data file can be fixed-length, or variable-length. Values can optionally be ended with a delimiter (see Delimiters in the Data File); the delimiter is specified in the copy list. copy can also process a special case of delimited values, the comma separated values (CSV) delimiting form.",
            "Note:  If II_DECIMAL is set to comma, you must follow any comma required in SQL syntax (such as a fixed-length copy type) by a space. For example:\ncopy table t (col1=c20, col2=c30, d0=nl) into \u2018t.out\u2019:\nBulk Copying\nTo improve performance when loading data from a file into a table, use a bulk copy. Bulk copy is possible for either formatted or unformatted copies.\nThe requirements for performing a bulk copy are:\n\u2022The table is not journaled\n\u2022The table has no secondary indexes\n\u2022For storage structures other than heap, the table is empty and occupies fewer than 18 pages\nIf the DBMS Server determines that all these requirements are met, the data is loaded using bulk copy. If the requirements are not met, data is loaded using a less rapid technique. For detailed information about bulk copying, see the Ingres Database Administrator Guide.\nTo specify the estimated number of rows to be copied from a file to a table during a bulk copy operation, use with row_estimate (see Row_estimate).\nColumn Formats for Copy\nThe following sections describe how to specify the data file format for table columns. The format specifies how each is written and delimited in the data file.\nNote:  When copying to or from a table that includes long varchar or long byte columns, specify the columns in the order they appear in the table.\nCharacter (Text) Formats\nThe character formats are the ones most commonly used to read and write ordinary text (human-readable) data files.\nThe basic character formats are byte, c, char, and text. Each has a variable-length form and a fixed-length form. The variable-length forms are byte(0), c0, char(0), and text(0). The fixed-length forms are byte(n), Cn, char(n), and text(n). An optional delim may follow to specify a delimiter.\nThe subtle differences between the various character formats are described in Copy Format Details.\nCounted Character Formats\nThe byte varying, long byte, long varchar, long nvarchar, nvarchar(n), and varchar formats are \"counted\" formats: each data file value is preceded by a character count. The character count defines the length of the data value; the actual field length as defined by a fixed-length specifier or a delimiter may be larger. On input (copy from), extra field characters beyond those included by the embedded character count are ignored. On output (copy into), any extra field length after the actual value is filled with padding, as defined by the specific format.\nThe fixed-length forms are byte varying(n), nvarchar(n), and varchar(n). The variable-length forms are byte varying(0), long byte(0), long varchar(0), long nvarchar(0), and varchar(0). An optional delim may follow to specify a delimiter.\nNote:  Nvarchar(0) is not a counted format.\nFor all fixed-length counted formats: the field length N does not include the preceding length specifier. For example, a varchar(1) field takes 6 bytes. When reading data (copy from), if the character count found in the data is larger than the defined length, a runtime conversion warning is issued and the row is not loaded.\nThese counted formats are the only ones that can be used with long table columns. The two long formats can only be used with long byte or long varchar table columns. See Copy Format Details.\nDummy Format\nThe D (dummy) format describes a data file column that does not map to any table column. On input (copy from), a D format column describes file data to be skipped and discarded. On output (copy into), a D format column describes constant data to be sent to the data file.\nThe column name given for any dummy column is not matched to any table column. The Dn form for copy into uses the column name as the value to output; all other uses of the dummy format ignore the column name completely.\nUnicode Formats\nThe Unicode formats are nchar, nvarchar, and long nvarchar and they can only be used with nchar or nvarchar table columns. Fixed-length forms are nchar(n) and nvarchar(n). Variable-length forms are nchar(0), nvarchar(0), and long nvarchar(0).\nFixed-length nchar(n) and nvarchar(n) formats read and write using the two-byte UCS-2 encoding. The variable-length nchar(0), nvarchar(0), and long nvarchar(0) forms read and write using the variable-length UTF8 encoding.\nThe field length n for nchar(n) and nvarchar(n) should be specified as character lengths, not byte (octet) lengths. However, the embedded length specifier used by the nchar(0) and nvarchar(0) formats should give the number of bytes, not characters. (The reason is that nchar(0) and nvarchar(0) use the UTF8 encoding, which encodes Unicode code points into a variable number of bytes. Copy needs the byte count to know how many bytes to read and decode from UTF8.)\nBinary Formats\nThe formatted copy statement supports binary formats that match the binary types used to store data in tables. These are the boolean, date, decimal, float, integer, and money formats (and size variants such as bigint, smallint, real, and so on). Most data files are text, not binary, so these binary formats are not often needed.\nCopy Format Details",
            "Copy Format Details\nThis section describes specifying the format of fields in the data file. When specifying data file formats for copy into, be aware of the following points:\n\u2022Data from numeric columns, when written to text fields in the data file, is right-justified and filled with blanks on the left.\n\u2022When a copy into statement is issued in the Terminal Monitor, the -i and -f command line flags control the format used to convert floating-point table data into text-type file data. To avoid rounding of large floating point values, use the sql command -f flag to specify a floating point format that correctly accommodates the largest value to be copied. For information about the -i and -f flags, see the sql command description in the Ingres Command Reference Guide.\n\u2022The copy into section often uses the phrase \"the display length of the corresponding table column\". This means the length of the table column when formatted as a character string. This will be a standard length based on the table column type, and is independent of the actual column value. For example: the display length of an integer column is 13, the display length of a smallint column is 6, and so on.\nThe following table explains the details for the various copy list formats. Unless otherwise noted, all non-binary formats can be followed by an optional delim to specify a delimiter (see Delimiters in the Data File).\nFormat\nHow Stored (copy into)\nHow Read (copy from)\nboolean\nWritten as a single byte Boolean value (0=FALSE, 1=TRUE). (A binary format)\nSame format as copy into\nbyte(0)\nSame as byte(n) where n is the display length of the corresponding table column.\nRead as variable-length binary data terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nbyte(n) where n\nis 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string. Exactly n bytes are written, padded with zeros if necessary. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string; exactly n bytes are read. If a delimiter is specified, one additional character is read and discarded.\nbyte varying(0)\nSame as byte varying(n) where n is the display length of the table column.\nRead as a variable-length byte string, preceded by a 5\u2011character, right\u2011justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nbyte varying(n) where n is 1 to the maximum row size configured, not exceeding 32,000.\nWritten as a fixed-length byte string preceded by a 5-character, right-justified length specifier. If necessary, the field is padded with zeros to the specified length. If given, the delimiter is written after the value and padding.\nRead as a fixed-length byte string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nC0\nSame as Cn where n is the display length of the corresponding table column\nRead as a variable-length string, terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nAny control characters or tabs in the input are converted to spaces. C0 format supports \\. The \\ is discarded, and the next character is taken literally as part of the value (even if it would normally be the delimiter). To read a \\ character, use \\\\.\nCn\nWritten as a fixed-length string, padded with blanks if necessary. Any \"non-printing\" character (meaning a control character or tab) is converted to a space. If given, the delimiter is written after the value and padding.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nAny control characters or tabs in the input are converted to spaces. Fixed-length Cn format does not support \\.\nchar(0)\nSame as char(n) where n is the display length of the corresponding table column.\nRead as a variable-length string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value.\nUnlike C format, char does not support \\. char also does not convert control characters or tabs. File data is read as is.\nchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string, padded with blanks if necessary. If given, the delimiter is written after the value and padding.\nUnlike C format, char does not do any conversion of control characters or tabs. Table data is output as-is.\nRead as a fixed-length string. If a delimiter is specified, one additional character is read and discarded.\nUnlike C format, char does not convert control characters or tabs. File data is read as is.\nD0\nInstead of placing a value in the file, copy writes the specified delimiter. (Unlike the Dn format, D0 format does not write the column name.)\nCopy into requires that a delimiter be specified; D0 with no delimiter is not allowed.",
            "Copy into requires that a delimiter be specified; D0 with no delimiter is not allowed.\nDummy field. Characters are read and discarded until the specified delimiter is encountered. If a delimiter is not specified, the first comma, tab, or newline ends the value.\nAny \\ found in the input means that the next character is to be taken literally, and is not a delimiter.\nDn\nDummy column. Instead of placing a value in the file, copy writes the name of the column n times. For example, if you specify x=D1, the column name, x, is written once; if you specify x=D3, copy writes xxx (the column name, three times), and so on. You can specify a delimiter as a column name, for example, NL=D1.\nDummy field. N characters are read and discarded.\nCopy from does not allow a delimiter specification with a fixed-length dummy field.\ndate\nWritten as a date. (A binary format)\nRead as a date. (A binary format)\ndecimal\nWritten as a decimal number. (A binary format.)\nRead as a decimal number. (A binary format)\nfloat\nWritten as double\u2011precision floating point. (A binary format)\nRead as double\u2011precision floating point. (A binary format)\nfloat4\nWritten as single\u2011precision floating point. (A binary format)\nRead as single\u2011precision floating point. (A binary format)\ninteger\nWritten as integer of 4\u2011byte length. (A binary format)\nRead as integer of 4\u2011byte length. (A binary format)\ninteger1\nWritten as integer of 1\u2011byte length. (A binary format)\nRead as integer of 1\u2011byte length. (A binary format)\nlong byte(0)\nIdentical to long varchar\nIdentical to long varchar\nlong nvarchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of bytes in UTF-8 encoding. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space).\nThe maximum segment size for the long nvarchar segment is 32727 bytes.\nThe UTF-8 encoded long nvarchar data segments are similar to long varchar data segments. See the description for long varchar(0) for an example of the encoded data segment.\nIf a delimiter is specified, it is written immediately following the last segment.\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nlong varchar(0)\nWritten in segments. Each segment is composed of an integer specifying the length of the segment, followed by a space and the specified number of characters. After the last data segment, a final zero-length segment is written (that is, 0 followed by a space). If a delimiter is specified, it is written immediately following the last segment. The maximum segment length is 32767.\nThe following example shows two data segments, followed by the termination zero length segment. The first segment is 5 characters long, the second segment is 10 characters long, and the termination segment is 0 character long:\n5 abcde10 abcdefghij 0 (with a space after the terminating 0 character)\n(In this example, the data that is in the originating table column is abcdeabcdefghij)\nRead under the same format as copy into. If a delimiter is specified, one character is read and discarded after the data value is read.\nmoney\nWritten as a scaled floating point value (a money value). (A binary format)\nRead as a scaled floating-point values (a money value). (A binary format)\nnchar(0)\nWritten as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified byte count. The exact length of the column value is written, without padding. If a delimiter is specified, it is written after the value.\nRead as a Unicode string in UTF-8 encoding, preceded by a 5-character, right-justified length specifier. (The length is a byte count, not a character count). If a delimiter is specified, additional input is discarded until the delimiter is encountered.\nnvarchar(0)\nSame as nchar(0)\nSame as nchar(0)\nnchar(n)\nWritten as a fixed-length Unicode string in UCS-2 encoding. N is the length in characters, not bytes. The value is padded to the specified length with UCS-2 blanks, if necessary. If a delimiter is specified, it is written after the value and padding.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nnvarchar(n)\nWritten as a 2-byte binary integer length specifier, followed by that many Unicode characters using UCS-2 encoding. The value is padded if necessary to the field length n; the padding content is undefined. If a delimiter is specified, it is written after the value and padding.\nThe byte length of the written value excluding delimiter is 2n+2; the length n is in characters, not bytes, and does not include the initial length specifier.\nRead using the same format as copy into. If a delimiter is specified, after the value is read, one additional character is read and discarded.\nsmallint\nWritten as an integer of 2\u2011byte length. (A binary format.)\nRead as integer of 2\u2011byte length. (A binary format)\ntext(0)\nWritten as a variable length string. If a delimiter is specified, it is written after the value.",
            "Written as a variable length string. If a delimiter is specified, it is written after the value.\nIf the originating column is C, char, or nchar, trailing blanks are trimmed. If the originating column is text, varchar, or nvarchar, the column value is output exactly as-is (no padding, no trimming). If the originating column is a non-character, writes the result of converting the value to a character string, as-is with no padding.\nCopy into using text(0) format is the way to get variable width output with no padding.\nRead as variable-length character string terminated by the specified delimiter. If a delimiter is not specified, the first comma, tab, or newline encountered ends the value\ntext(n)\nWritten as a fixed-length string. The value is padded with null bytes (zeros) if necessary. If specified, the delimiter is written after the value and padding.\nReads a fixed-length field n characters wide; however if one of those characters is a null byte, the value stored into the table is terminated at that null byte. If a delimiter is specified, one additional character is read and discarded.\nvarchar(0)\nSame as varchar(n), where n is the display length of the corresponding table column.\nRead as a variable-length string, preceded by a 5\u2011character, right-justified length specifier. If a delimiter is specified, additional input is discarded until the delimiter is found.\nvarchar(n)\nwhere n is 1 to the maximum row size configured, not exceeding 32,000 (16,000 in a UTF8 instance).\nWritten as a fixed-length string preceded by a 5-character, right\u2011justified length specifier. If necessary, the value is padded with null characters to the specified length.\nRead as a fixed-length string, preceded by a 5-character, right-justified length specifier. If a delimiter is specified, one additional character is read and discarded.\nNote:  The dummy format (dn) behaves differently for copy from and copy into. When a table is copied into a file, n specifies the number of times the column name is repeated. When copying from a file to a table, n specifies the number of bytes to skip.\nFor user-defined data types (UDTs), use char or varchar.\nDelimiters in the Data File\nDelimiters are characters in the data file that separate fields and mark the end of records. Valid delimiters are listed in the following table:\nDelimiter\nDescription\nnl\nNewline character\ntab\nTab character\nsp\nSpace\ncsv\nComma separated values\nssv\nSemicolon separated values\nnul or null\nNull/zero character\ncomma\nComma\ncolon\nColon\ndash\nDash\nlparen\nLeft parenthesis\nrparen\nRight parenthesis\nX\nAny non-numeric character\nWhen a single character is specified as the delimiter, enclose that character in quotes. If the data type specification is C or D, the quotes must enclose the entire format. For example, 'd0%' specifies a dummy column delimited by a percent sign (%). If the data type specification uses parentheses around the length, quote only the delimiter. For example, char(0)'%' specifies a char field delimited by a percent sign.\nBe careful using the sp (space) or null delimiters, especially with copy from. Spaces or nulls are used as padding characters by many of the copy formats. If a pad character is improperly treated as a delimiter, the copy from will get out of sync with the input, eventually producing an error. When designing a data file format, use delimiters that will not appear in the data or padding, or use CSV or SSV forms.\nCSV and SSV Delimiters\nThe CSV and SSV delimiters allow copy to read and write files that contain comma separated values (CSV).\nThe rules for a CSV-delimited field are:\n\u2022The field is delimited by a comma, unless it is the last CSV-delimited field in the copy list and all following fields are dummy fields; in that case, the field is delimited by a newline.\n\u2022Copy from: If the first non-blank character in the field is a double quote (\"), the field extends until a closing double quote. Commas or newlines inside the quoted string are not delimiters and do not end the value. If a doubled double quote (\"\") is seen while looking for the closing quote, it is translated to one double quote and the value continues. For example, the data file value:\n\u201cThere is a double quote \u201c\u201d here\u201d\nis translated to the table value:\nThere is a double quote \u201c here\nWhitespace before the opening double quote, or between the closing double quote and the delimiter (comma or newline), is not part of the value and is discarded.\n\u2022Copy into: If the value to be written contains a comma, newline, or double quote, it is written enclosed in double quotes using quote doubling as described in the previous bullet item. If the value does not contain a comma, newline, or double quote, it is written as is.\nThe SSV delimiter works exactly the same as the CSV delimiter, with semicolon in place of comma.\nCSV and SSV delimiters are only allowed with byte(0), C0, char(0), and text(0). They are not allowed with the \u201ccounted\u201d formats (varchar(0) and so on); the count defines the value exactly and there is no need for quoting. (If delimiting is desired, use the comma or nl delimiters on counted formats.)",
            "Copy from: Some CSV file variants use quote escaping (\\\") instead of quote doubling (\"\") to indicate a quote inside a quoted string. The C format handles\\- escaping, so use the C0CSV format and delimiter to handle this type of file. (CSV with copy into always writes quote doubling\u2014never quote escaping\u2014when needed.)\nWith Null Clause for Copy\nThe with null clause allows the data file to contain null data. There are two methods of indicating a null: an indicator byte (no value given), or a special user-defined marker value. The indicator byte method does not depend on a particular marker value, but it is a binary form not suited to human readable text files. Also, the indicator byte method is not available for variable-length data fields. The user-defined marker value method works with any file format, but depends on a user chosen value that must not otherwise appear in the data.\nWith Null (value) Clause\nWhen copying data from a table to a file, the with null (value) clause directs copy to put the specified value in the file when a null is detected in the corresponding column. If a null is detected and there is no with null clause, a runtime error occurs, and aborts the copy statement.\nWhen copying data from a file to a table, the with null (value) clause specifies a marker value to be interpreted as a null. When copy encounters this value in the file, it writes a null to the corresponding table column. The table column must be nullable; if it is not, a runtime error occurs, and aborts the copy statement.\nTo prevent conflicts between valid data and null entries, choose a value that does not occur as part of the data in your table. The value chosen to represent nulls must be compatible with the format of the field in the file: character formats require quoted values, and binary numeric formats require unquoted numeric values.\nFor example, this example of a value is incorrect:\nc0comma with null(0)\nbecause the value specified for nulls (numeric zero) conflicts with the character data type of the field. However, this example is correct:\nc0comma with null('0')\nbecause the null value is character data, specified in quotes, and does not conflict with the data type of the field. Do not use the keyword null, quoted or unquoted, for a numeric format.\nWhen copying from a table to a file, be sure that the specified field format is at least as large as the value specified for the with null clause. If the column format is too small, the DBMS Server truncates the null value written to the data file to fit the specified format.\nFor example, in the following statement the string, 'NULL,' is truncated to 'N' because the format is incorrectly specified as one character:\ncopy table t1 (col1 = char(1) with null ('NULL')) into 't1.dat';\nThe correct version specifies a 4-character format for the column.\ncopy table t1 (col1 = char(4) with null ('NULL')) into 't1.dat';\nWith Null Clause Omitting Value\nIf with null is specified but value is omitted, copy uses a trailing indicator byte in the file to determine whether a file value is a null. Copy into writes a zero trailing byte if the value is not null; it writes a nonzero trailing byte to indicate a null. (The value written prior to the indicator byte is undefined if the indicator shows null.) Copy from reads and interprets a trailing indicator byte in the same manner, zero for not null and nonzero for null. Indicator bytes are not allowed for variable-length formats such as char(0); variable-length formats must specify a value clause.\nFilename Specification for Copy\nFilename must be enclosed in single quotation marks; the file specification can include a directory/path name. For copy into, if the file does not exist, copy creates the file.\nUNIX: For copy into, if the file already exists, copy overwrites it.\nWindows File Types for Copy\nFile type can be specified using the optional type parameter. Type must be either T for text, or B for binary.\nThe traditional Windows newline indicator is a CR-LF pair (carriage return / linefeed). The newline indicator on other operating systems (such as UNIX) is a single linefeed with no carriage return. Windows uses the file type to control translation between Windows and UNIX style newline indicators, as well as control-Z translation.\nA file in binary type mode reads or writes the data exactly as is, with no translation. A file in text type mode translates a single LF to CR-LF when writing. When reading a file in text mode, CR-LF pairs are read as single LF's, and if a control-Z occurs in the data file, end-of-file is returned and Windows stops reading data from that file.\nBy default, Ingres uses text mode for copy into and copy from only if all of the listed field formats are character types (c, char, text, varchar, or dummy). Otherwise, binary mode is used.\nThe binary-copy forms (copy () from or copy () into) use binary mode.\nNote:  Unicode formats (nchar, nvarchar), long varchar format, and the byte formats cause binary mode to be used by default.",
            "Copy from recognizes CR-LF as a newline (nl) delimiter even if the input file is read in binary type mode. (This is true on non-Windows systems too, so that data files that were created by Windows applications can be read.)\nFor situations where the default file type choice is inappropriate, the file type can be specified explicitly. For example, if copy into is creating a file to be read on a UNIX system, a file type of B (Binary) is appropriate. The resulting file will contain UNIX-style newlines (single linefeeds) instead of Windows-style newlines.\nWith Clause for Copy\nValid with clause options for the copy statement are as follows:\nOn_error=TERMINATE|CONTINUE\non_error = TERMINATE | CONTINUE\nDirects copy to continue after encountering conversion errors.\nTo direct copy to continue until a specified number of conversion errors have occurred, specify the error_count option instead.\nBy default, copy terminates when an error occurs while converting between table format and file format\nWhen on_error is set to CONTINUE, copy displays a warning whenever a conversion error occurs, skips the row that caused the error, and continues processing the remaining rows. At the end of the processing, copy displays a message that indicates how many warnings were issued and how many rows were successfully copied.\nSetting on_error to CONTINUE does not affect how copy responds to errors other than conversion errors. Any other error, such as an error writing the file, terminates the copy operation.\nError_count=n\nerror_count = n\nSpecifies how many errors can occur before processing terminates.\nDefault: 1.\nIf on_error is set to continue, setting error_count has no effect.\nLog='filename'\nlog = 'filename'\nStores to a file any rows that copy cannot process. This option can be used only if on_error CONTINUE is specified. When specified with log, copy places any rows that it cannot process into the specified log file. For copy into, the logged rows are in database (binary) format; for copy from, the logged rows are in file format.\nLogging works as follows:\nWindows: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nUNIX: Copy opens the log file prior to the start of data transfer. If it cannot open the log file, copy halts. If an error occurs when writing to the log file, copy issues a warning, but continues. If the specified log file already exists, it is overwritten with the new values (or truncated if the copy operation encounters no bad rows).\nThe log option is not available if the table contains any long columns, whether they are part of the copy list or not.\nIf copying from a data file that contains duplicate rows (or rows that duplicate rows already in the table) to a table that was created with noduplicates and has a HASH, ISAM or BTREE storage structure, copy displays a warning message and does not add the duplicate rows. If the with log option is specified, copy does not write the duplicate rows to the log file.\nIf copying from a data file that contains duplicate keys (or keys that duplicate keys already in the table) to a table that enforces the unique key, copy displays a warning message and does not add the rows containing the duplicate keys. This operation is sequential so that the first row is copied to the table and a second row with the same key fails.\nRollback=ENABLED|DISABLED\nrollback = ENABLED | DISABLED\nEnables or disables rollback, as follows:\nENABLED\nDirects the DBMS Server to back out all rows appended by the copy if the copy is terminated due to an error.\nDISABLED\nRetains the appended rows.\nThe rollback=DISABLED option does not mean that the copy cannot be rolled back. Database server errors that indicate data corruption will always roll back the copy statement. In addition, the user may decide to rollback the entire transaction rather than committing it with a commit.\nDefault: ENABLED\nWhen copying to a file, the with rollback clause has no effect.\nRow_estimate\nrow_estimate\nSpecifies the estimated number of rows to be copied from a file to a table during a bulk copy operation. The DBMS Server uses the specified value to allocate memory for sorting rows before inserting them into the table. An accurate estimate can enhance the performance of the copy operation.\nThe estimated number of rows must be no less than 0 and no greater than 2,147,483,647. If this parameter is omitted, the default value is 0, in which case the DBMS Server makes its own estimates for disk and memory requirements.\nPermissions\nTo use the copy statement, one of the following must apply:\n\u2022You own the table.\n\u2022The table has select (for copy into) or insert (for copy from) privilege granted to PUBLIC.\n\u2022You have been granted COPY_INTO (for copy into) or COPY_FROM (for copy from) privileges on the table.\nLocking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.",
            "Locking\n\u2022When copying from a table into a file, the DBMS Server takes a shared lock on the table.\n\u2022When performing a bulk copy into a table, the DBMS Server takes an exclusive lock on the table. Because bulk copy cannot start until it gets an exclusive lock, this operation can be delayed due to lock contention.\n\u2022When performing a non-bulk copy into a table, the DBMS server takes an \u201cintent exclusive\u201d lock on the table, and uses insert to update the table. As a result, the operation can be aborted due to deadlock.\nRestrictions and Considerations\nCopy cannot be used to add data to a view, index, or system catalog.\nWhen copying data into a table, copy ignores any integrity constraints defined (using the create integrity statement (see Create Integrity Statement)) against the table.\nWhen copying data into a table, copy ignores ANSI/ISO Entry SQL-92 check and referential constraints (defined using the create table (see Create Table Statement) and alter table statements), but does not ignore unique (and primary key) constraints.\nThe copy statement does not fire any rules defined against the table.\nValues cannot be assigned to SYSTEM_MAINTAINED logical key columns. The DBMS Server assigns values when copying from a data file to a table. This occurs even if the logical key column is being implicitly loaded using an unformatted copy; the values in the data file are ignored, and new values assigned by the DBMS Server.\nCopy treats a present-but-empty field in the data file as:\n\u2022A blank default for character-based columns\n\u2022A zero default for numeric columns\n\u2022December 31 00-1 for date and timestamp columns\n\u202200:00:00 for time columns (and the time component in a timestamp)\nFor example, if you load a data file (copy from) that contains a record with one empty value into a table with a mandatory (not default) integer field, the load of the one record does not fail due to the missing value, but succeeds and loads a 0. You do get the error for the missing value if the column is omitted from the copy list. Note that if the table has a column defined with a default value and the field in the data file is present but empty, copy loads the default as listed above. If you omit the column from the copy list then you will get the proper default value.\nRelated Statements\nCreate Table Statement\nModify Statement\nExamples--Copy Statement\nThe following examples illustrate the correct use of the copy statement:\n1.In the following Data File Format example, the contents of the file, emp.txt, are copied into the employee table. To omit the city column, a dummy column is employed. The format of the employee table is as follows:\nename     char(15)\n    age       integer4\n    dept      char(10)\n    comment   varchar(20)\nThe emp.txt file contains the following data:\nJones,J. 32 Anytown,USA toy,00017A This is a comment\nSmith,P. 41 New York,NY admin,00015 Another comment\nThe following diagram illustrates the copy statement that copies the file, emp.txt, into the employee table, and maps the fields in the file to the portions of the statement that specify how the field is to be copied. Note the following points:\nA dummy column is used to skip the city and state field in the data file, because there is no matching column in the employee table.\nThe department field is delimited by a comma.\nThe comment field is a variable-length varchar field, preceded by a five-character length specifier.",
            "2.Load the employee table from a data file. The data file contains binary data (rather than character data that can be changed using a text editor).\ncopy table employee (eno=integer2, ename=char(10),\n    age=integer2, job=integer2, sal=float4,\n    dept=integer2, xxx=d1)\n    from 'myfile.in';\n3.Copy data from the employee table into a file. The example copies employee names, employee numbers, and salaries into a file, inserting commas and newline characters so that the file can be printed or edited. All items are stored as character data. The sal column is converted from its table format (money) to ASCII characters in the data file.\ncopy table employee (ename=char(0)comma,\n    eno=char(0)comma, sal= char(0)nl)\n    into 'mfile.out';\nJoe Smith , 101, $25000.00\n\nShirley Scott , 102, $30000.00\n4.The same example as #3, except that text format is used to eliminate all padding. The comma-separated-values delimiter is used.\ncopy table employee (ename = text(0)csv,\n    eno = text(0)csv, sal = text(0)csv)\n    into 'mfile.out';\n \nJoe Smith,101,$25000.00\nShirley Scott,102,$30000.00\n5.Bulk copy the employee table into a file. The resulting data file contains binary data.\ncopy table employee () into 'ourfile.dat';\n6.Bulk load the file created in the preceding example into another table. The other_employee_table must have the same column definitions as the employee table.\ncopy table other_employee_table () from 'ourfile.dat';\n7.Copy the acct_recv table into a file. The following statement skips the address column, uses the percent sign (%) as a field delimiter, uses 'xx' to indicate null debit and credit fields, and inserts a newline at the end of each record.\ncopy table acct_recv\n    (acct_name=char(0)'%',\n    address='d0%',\n    credit=char(0)'%' with null('xx'),\n    debit=char(0)'%' with null('xx'),\n    acct_mngr=char(15),\n    xx=d0nl)\n    into 'qtr_result';\nSmith Corp%% $12345.00% $-67890.00%Jones\nABC Oil %% $54321.00% $-98765.00%Green\nSpring Omc%%xx %xx %Namroc\n8.Copy a table called, gifts, to a file for archiving. This table contains a record of all non-monetary gifts received by a charity foundation. The columns in the table contain the name of the item, when it was received, and who sent it. Because givers are often anonymous, the column representing the sender is nullable.\ncopy table gifts\n    (item_name=char(0)tab,\n    date_recd=char(0)tab,\n    sender=char(20)nl with null('anonymous'))\n    into 'giftdata';\ntoaster 04-mar-1993 Nicholas\nsled 10-oct-1993 anonymous\nrocket 01-dec-1993 Francisco\n9.Create a table and load it using bulk copy, specifying structural options.\ncreate table mytable (name char 25, ...);\n\nmodify mytable to hash;\n\ncopy mytable() from 'myfile' with minpages = 16384,\nmaxpages = 16384, allocation = 16384;"
        ]
    }
]