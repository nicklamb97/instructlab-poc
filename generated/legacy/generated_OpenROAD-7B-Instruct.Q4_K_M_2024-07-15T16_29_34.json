[
    {
        "instruction": "What are some common errors when using Actian 4GL?",
        "input": "",
        "output": "Some common errors include syntax errors, undefined variables, and invalid references. Syntax errors occur when you make mistakes in the code such as typos or incorrectly formed statements. Undefined variables happen when you try to access a variable that has not been initialized yet. Invalid references occur when you reference an object that does not exist anymore or when you use an invalid identifier for something.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How do you declare a new class in Actian 4GL?",
        "input": "",
        "output": "To declare a new class, use the CLASS statement:\n```4gl\nCLASS my_class {\n   ATTRIBUTES:\n      name AS CHAR(20);\n      age AS INTEGER;\n   METHODS:\n      speak() {\n         PRINT('Hello, I am ' + this.name + ' and I am ' + this.age + ' years old.');\n      }\n}\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "What is the syntax of the alter group statement?",
        "input": "",
        "output": "The alter group statement has the following syntax:\nalter group group\\_id {, group\\_id}\nModifies the list of users associated with a group identifier (group\\_id).\nThe group\\_id must be an existing group identifier. If a non-existent group\\_id is specified, a warning is issued and processing continues with the next valid group\\_id in the list.\nadd users (user\\_id {, user\\_id}) | drop users (user\\_id {, user\\_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group\\_id {, group\\_id}\nModifies the list of users associated with a group identifier (group\\_id).\nThe group\\_id must be an existing group identifier. If a non-existent group\\_id is specified, a warning is issued and processing continues with the next valid group\\_id in the list.\nadd users (user\\_id {, user\\_id})\nAdds the specified user\\_ids to the specified the group\\_ids.\nThe user\\_ids must exist to be added to a group. If a specified user\\_id does not exist, an error is issued and processing continues with the remaining user\\_ids.\nIf a specific user\\_id occurs more than once in the user list, additional occurrences of the specified user\\_id are ignored. No errors are issued.\ndrop users (user\\_id {, user\\_id})\nRemoves the specified user\\_ids from the specified the group\\_ids.\nIf a specified user\\_id is not in the group user list, an error is issued and processing continues with the remaining user\\_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group\\_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain\\_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales\\_clerks.\nalter group sales\\_clerks\nadd users (dannyh, helent);\n2.Drop three users from the group, tel\\_sales.\nalter group tel\\_sales\ndrop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;\n\nHere are some more examples to help you understand the type of questions that are asked for this document:",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "What is the purpose of the alter group statement?",
        "input": "",
        "output": "The alter group statement modifies the list of users associated with a group identifier. This allows you to add or drop individual users, or even remove all users from the group.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "How does the alter group statement affect sessions on the server?",
        "input": "",
        "output": "The alter group statement locks pages in the iiusergroup catalog in the iidbdb, which causes any sessions attempting to connect to the server to be suspended until the alter group statement is completed. This prevents other users from making changes to the group while you are working on it.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "What are some common uses of the alter group statement?",
        "input": "",
        "output": "Some common uses of the alter group statement include:\n* Adding or removing individual users from a group\n* Changing the default group for a user\n* Dropping all users from a group in an application",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "What are some limitations of the alter group statement?",
        "input": "",
        "output": "Some limitations of the alter group statement include:\n* It cannot be used to create a new group or destroy an existing one\n* It cannot modify the permissions or privileges of any user within a group\n* It cannot add or remove members from another group",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "How can you specify a dynamic name for the table or column in an insert statement?",
        "input": "",
        "output": "You can use the following syntax to specify a dynamic name for the table or column:\n```4gl\nname = 'Destry';\n```\nOr, for specifying a dynamic column name:\n```4gl\ncolumnname = 'Name';\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "How do you use the IN clause in Actian 4GL?",
        "input": "",
        "output": "The IN clause is used to test a condition against a set of values. For example, in the following statement:\n```4gl\nIF (name IS NOT NULL) THEN DO:\n```\nthe previous statement tests the name variable for nullness. The previous statement does nothing if the name variable is null.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How do you use the CASE statement in Actian 4GL?",
        "input": "",
        "output": "The CASE statement is used to evaluate a condition and perform an action based on the result. For example, in the following statement:\n```4gl\nCASE salary WHEN >= 100000 THEN DO:\n```\nthe previous statement increases the salary of the employee if it is greater than or equal to 100,000. The previous statement does nothing otherwise.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How can you remove all users from a group in Actian 4GL?",
        "input": "",
        "output": "You can do this by using the drop all clause of the alter group statement. This removes all users from the specified group_ids. If any member of the specified group has that group as its default group, dropping all results in an error. Use the alter user statement to change a user's default group instead.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "How can you insert a computed value into a database table using an insert statement?",
        "input": "",
        "output": "You can use the following syntax to insert a computed value into a database table:\n```4gl\nrepeated insert into tablename (columnname, expression)\n     values (null, expression);\n```\nWhere 'expression' represents the SQL expression that evaluates to the appropriate data type.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "How can you insert data from a subselect into a database table using an insert statement?",
        "input": "",
        "output": "You can use the following syntax to insert data from a subselect into a database table:\n```4gl\nrepeated insert into tablename (columnname, expression)\n     select * from subselect;\n```\nWhere 'subselect' represents the select statement that serves as the source of values.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "How do you sort records in Actian 4GL?",
        "input": "",
        "output": "You can use the ORDER BY clause to sort records in Actian 4GL:\n```4gl\nORDER BY column1 DESC, column2;\n```\nExample:\n```4gl\nORDER BY last_name, first_name;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "Can you create a window with Actian 4GL?",
        "input": "",
        "output": "No, you cannot create a window with Actian 4GL:\n```4gl\nCREATE WINDOW 'my_window';\n```\nExample:\n```4gl\nCREATE DATABASE 'my_database';\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "Describe the syntax of the alter group statement.",
        "input": "",
        "output": "The alter group statement has the following syntax:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "How can you use the add users parameter to add new users to a group?",
        "input": "",
        "output": "You can use the add users parameter to specify the user_ids of the new users that you want to add to the group. For example:\nadd users (dannyh, helent);\nThis statement adds the specified user_ids to the list of users associated with the group. The user_ids must exist in order for them to be added to the group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids. If a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "How do you specify the values to insert in an insert statement?",
        "input": "",
        "output": "You can use either a values clause or a subselect to specify the values to be inserted into the database:\n\nFor example, here is how you might use a values clause:\n```4gl\ninsert into projects (name, duedate)\nvalues ('ACME Corporation', '2021-07-15');\n```\nOr, if you prefer, you can use a subselect like this:\n```4gl\nrepeated insert into personnel (name, sal)\nselect name, salary from contractor\nwhere name = :f_name and age = :f_age;\ncommit;\n```\nThese examples demonstrate how easy it is to specify the values for any type of insert statement in Actian 4GL.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "How do you omit the list of database columns when using a subselect or values clause?",
        "input": "",
        "output": "You can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created. Here is an example:\n```4gl\ninsert into projects (name, duedate)\nvalues (:projname, :enddate);\n```\nIn this example, you are not specifying any columns for the insert statement, but instead using a subselect to retrieve the required data. The subselect has been defined with its own set of columns, which match those required by the insert statement. Therefore, Actian 4GL can automatically determine which column values to use when executing this statement.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "How do you declare an enumerated type in Actian 4GL?",
        "input": "",
        "output": "To declare an enumerated type in Actian 4GL, use the following statement:\n```4gl\nENumeration MyEnum {\n   values are (red, green, blue);\n};\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How do you define the values of an enumeration?",
        "input": "",
        "output": "The values of an enumeration are defined using the 'values are' clause in the enum declaration statement. For example, in the previous statement:\n```4gl\nENumeration MyEnum {\n   values are (red = 1, green = 2, blue = 3);\n};\n```\nthe previous statement defines three color enumeration variables with their respective integer values.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How do you use an enumerated type as a parameter or return value from a procedure or function?",
        "input": "",
        "output": "You can pass an enumeration variable to a procedure or function as either an implicit reference or a named parameter. When you declare the parameter in the call statement, specify the name of the variable and the type of it. For example:\n```4gl\nPROCEDURE SetColor(color ENumeration) {\n  color = red;\n}\n```\nthe previous procedure changes the color enumeration variable to red. You can also return an enumeration from a procedure or function using the 'return' statement. For example:\n```4gl\nFUNCTION GetRandomColor():\n  return (rand(1) > 0.5)? green : blue;\n}\n```\nthe previous function returns either green or blue depending on the random number generated by the rand() function.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How do you write a select statement that returns rows with no columns (i.e., just data)?",
        "input": "",
        "output": "To write a select statement that returns only data, use the following statement:\n```4gl\nSELECT col1, col2 FROM table1;\n```\nthe previous statement selects the first two columns from the 'table1' object. The previous statement does not specify any conditions in the WHERE clause, so all rows are selected. You can also use the * wildcard character to select all columns:\n```4gl\nSELECT * FROM table1;\n```\nthe previous statement selects all columns from the 'table1' object.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "What is the purpose of a subselect in an insert statement?",
        "input": "",
        "output": "A subselect specifies a select statement that serves as the source of values to be inserted.\nExample:\n```4gl\nrepeated insert into employee(name, salary)\nselect name, salary from contractor where id = :f_id;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "How do you specify the list of database columns when using a subselect in an insert statement?",
        "input": "",
        "output": "You can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExample:\n```4gl\nrepeated insert into employee(name, salary)\nselect name, salary from contractor;\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "How do you create an empty table in Actian 4GL?",
        "input": "",
        "output": "To create an empty table in Actian  4GL, you can use the following statement:\n```4gl\nCREATE TABLE emptable (\n   name VARCHAR(30) NOT NULL,\n   salary NUMERIC(6,2) NOT NULL,\n   overpaid BOOLEAN NOT NULL,\n   PRIMARY KEY (name)\n);\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How do you set the initial value of a property in Actian 4GL?",
        "input": "",
        "output": "To set the initial value of a property in Actian 4GL, you can use the following statement:\n```4gl\nPROPERTY(name) = 'Your Name Here';\n```\nwhere 'Your Name Here' is the desired value for the property. The previous statement sets the name property to this value when the object is created.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How does Actian 4GL handle errors and exceptions that occur during execution of a statement?",
        "input": "",
        "output": "When an error or exception occurs while executing a statement in Actian 4GL, the system logs it and notifies you through the console or GUI. If the error is severe enough to prevent further processing of the statement, then the system rolls back all changes made since the last successful operation in the statement, restoring any affected resources back to their original states. This ensures data integrity and consistency throughout the entire application lifecycle, even when unexpected issues arise.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    },
    {
        "instruction": "How can you specify the list of database columns for an insert statement?",
        "input": "",
        "output": "You can use either of these methods to specify the list of database columns for an insert statement:\n- By naming each column individually, like this:\n  ```4gl\n  insert into tablename (columnname1, columnname2, ...)\n      values (expression1, expression2, ...);\n  ```\n- Or by using the wildcard character (*), like this:\n    ```4gl\n    insert into tablename *\n        values (expression1, expression2, ...);\n    ```\nWhere 'expression' represents the SQL expression that evaluates to the appropriate data type.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "How can you omit the list of database columns when using a subselect or values clause in an insert statement?",
        "input": "",
        "output": "You can use the following syntax to omit the list of database columns when using a subselect or values clause:\n```4gl\ninsert into tablename (columnname1, columnname2, ...)\n     select expression from table;\nor\n     values (expression, expression, ...);\nwhere 'expression' represents the SQL expression that evaluates to the appropriate data type.\nIn this case, OpenROAD assumes the order of columns in the subselect or values clause matches the order of columns in the table when it was created. If not, then you receive an error and the statement is not executed.\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->insert_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL insert statements.",
        "document": [
            "Insert Statement\nThis statement inserts rows into a database table.\nThis statement has the following syntax:\n[repeated] insert into tablename [(columnname {, })]\n          values(expression{, expression}) | subselect;\nThe insert statement inserts new rows into the specified database table.\nWhen you specify columnname, you must specify any column that is defined \u201cnot null not default.\u201d If you do not specify such columns, you receive an error and the statement is not executed. Columns that are nullable or defaultable can be specified or not, as appropriate. If unspecified, they receive default values. (OpenROAD default values are null if the column is nullable, or blank for character data type columns and zero for numeric columns.)\nThe repeated keyword directs the database to encode and save the query execution plan, providing performance benefits if you intend to execute this statement more than once. Valid only for the Ingres DBMS.\nDo not use the repeated keyword if your statement uses a dynamic name for the table name, a column name, or in the subselect clause.\nFor more information about the insert statement, see the Programming Guide.\nParameters--Insert Statement\nThis statement has the following parameters:\ntablename\nSpecifies the name of the database table into which rows are to be inserted. This is a dynamic name.\ncolumnname\nSpecifies the name of a column within the database table that receives the value. This is a dynamic name.\nexpression\nSpecifies an SQL expression that must evaluate to the appropriate data type.\nThis expression has the restriction that it must not contain references to database column names.\nsubselect\nSpecifies a select statement that serves as the source of values to be inserted\nValues Clause and Subselect\nTo specify the values to insert, use the values clause or a subselect.\n\u2022In the values clause, expression represents the value that you are inserting into the database.\n\u2022When you use a subselect, the values to insert are retrieved by the select statement. For more information about subselects, see Select Statement.\nYou can omit the list of database columns if the inserted values come from a subselect and the column types in the subselect match the column types in the table in the order specified when the table was created.\nExamples--Insert Statement\nInsert the values of projname and enddate into the projects table and then commit the changes:\ninsert into projects(name, duedate)\n     values(:projname, :enddate);\ncommit;\nInsert a computed value into the personnel table:\nrepeated insert into personnel(name, sal)\n     values(:name, :salary*1.1);\nInsert data from the contractor table into the personnel table, according to qualifying criteria, then commit the changes:\nrepeated insert into personnel(name, sal)\n     select name, salary from contractor\n          where name = :f_name and age = :f_age;\ncommit;\nTake the rows from the emptable array and insert them into the database:\ni = 1;\nwhile i <= emptable.LastRow do\n     repeated insert into employee(name, age, salary)\n          values(:emptable[i].name,\n               :emptable[i].age,\n               :emptable[i].salary);\n     i = i + 1;\nendwhile;"
        ]
    },
    {
        "instruction": "What are some common functions that can be used in a select statement?",
        "input": "",
        "output": "Some common functions that can be used in a select statement include:\n- Opening a file or connection to it:\n```4gl\nFILE(filename) = 'C:\\path\\to\\myfile.txt';\n```\nor\n```4gl\nCONNECTION(name) = 'Destiny Database';\n```",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "How do you create a new record in the database using Actian 4GL?",
        "input": "",
        "output": "To create a new record in the database, you can use the following statement:\n```4gl\nINSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);\n```\nwhere 'table_name' is the name of the table into which you want to insert the new record, and 'value1', 'value2', etc., are the values for the columns in that table. After executing this statement, 4GL opens a new record in the specified table and fills in the appropriate fields with the specified values.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->select_statements",
        "task_description": "Learn about the syntax of Actian 4GL SQL select statements.",
        "document": [
            "of constants in the search condition. For example:\nwhere dept = :var and name = 'Jones' and\n     age > :age\nYou can also place the entire search condition in a varchar variable. For example:\nqual = 'dept = ''mktg'' and age > 10 and name =\n     ''Jones''';\n...\nselect...\nfrom...\nwhere :qual;\nTo build up a search condition from the contents of existing varchar and numeric variables, you could do something like this:\nqual = 'dept = ''mktg'' and age > ' + varchar(age) + ' and name =\n          ''' + ename + '''';\nIf you place the entire search condition in a varchar variable, you cannot use the repeated keyword in the select statement.\nOrder By Clause\nThe order by clause lets you specify how the returned rows are ordered. Its syntax is:\norder by orderspecification{, orderspecification}\nwhere orderspecification is:\nname |number [sortorder]\nYou can use either the names or numbers to specify the order, but not both. Additionally, if you use a dynamic name to specify either name or sortorder, you cannot use the repeated option in the select statement.\nThe name must be taken from a simple_variable, resultname, or dbexpression (if it specifies a database column and simple_variable and resultname are omitted) in the select's target list. If the name in the select target list is expressed with dot notation, use the last component of that notation as the name in the order by clause. For example:\nselect empname as name,\nempage as e.age,\nempsalary as emptab[3].salary\nfrom emptable\norder by age, salary, name\nThe number is the ordinal position of the name in the select target list. For example, consider the following select statement:\nselect empname as e.name\n       department as e.dept\nfrom emptable\norder by 2, 1\nbegin...\nIn this statement, e.name is in ordinal position one in the target list and e.dept is in ordinal position two. In the order by clause, we are directing the DBMS to order the returned rows by the variable name in position two, that is, e.dept (the department) and then by the variable name in position one, e.name.\nIf you include more than one name or number, the DBMS orders the rows on the basis of the first item, the second item, and so on. For example, assume that your application has the following select statement:\nselect ename as employee_name, dept as dept,\n     salary as salary, eage as age\nfrom employee\norder by dept, employee_name, salary asc;\nIf the returned rows are displayed in a table field, the user sees them sorted in this manner:\nDept\nName\nSalary\n1\nAdams, Harold\n35,000\n1\nJames, Clarice\n36,000\n1\nJames, Donna\n27,000\n2\nGordon, Gerard\n37,000\n2\nSevarino, Juan\n31,000\nThe rows are sorted first by department, then within each department by name, and within each name (if two are the same) by salary.\nThe sortorder determines how each item is sorted within itself. You can specify an ascending (asc) or descending (desc) sort order for each item. If you do not specify sortorder, the default is ascending.\nIf you are sorting by names that are the same, you must use numbers. For example, numbers must be used in the following order by clause:\nselect empname as e.name,\nmgrname as m.name\nfrom emptable\norder by 1, 2\nUsing a Select Loop\nA select loop is one or more operations that the program performs on each row of values returned by a select statement. Because select loops provide better performance than cursors, you should use select loops whenever the operations that you want to perform on the returned rows are completed within a single event block.\nThe begin and end keywords define the statement block that is the select loop. You can use any legal 4GL statement in the statement list.\nThe system variable IIrowcount has an undefined value during the execution of a select loop unless you execute a query statement as part of the loop. In such cases, the value of IIrowcount is defined for that statement. After the select loop completes, the value in IIrowcount reflects the number of rows processed by the loop.\nFor more information about using select loops and cursors, see the Programming Guide.\nExamples--Select Statement\nSelect information about an employee based on the value in the empnum field. Then use the commit statement to end the transaction:\nselect last as lname, first as fname\nfrom personnel\nwhere empnum = :empnum;\ncommit;\nSelect rows for all employees with an employee number greater than 100, then use the commit statement to end the transaction. The table name is held in a variable:\ntbl = 'employee';\nselect last as lname, first as fname,\nemployee as empnum\nfrom :tbl\nwhere number >100;\ncommit;\nRead into the emptable array all projects for the employee whose number is currently displayed in the empnum field, then use the commit statement to end the transaction:\ni = 1;\nrepeated select project as emptable[i].project,\nhours as emptable[i].hours\nfrom projects\nwhere empnum = :empnum\nbegin\n     i = i + 1;\nend\ncommit;\nRetrieve the name and salary and set a variable to indicate the status of the salary:\ni = 1;\nselect name as name, salary as salary\nfrom emptable\nbegin\n     if salary > 100000 then\n          overpaid = TRUE;\n     else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;",
            "else\n          overpaid = FALSE;\n     endif;\n     emptable[i].name = name;\n     emptable[i].salary = salary;\n     emptable[i].overpaid = overpaid;\n     i = i + 1;\nend"
        ]
    },
    {
        "instruction": "Describe the permissions required to execute the alter group statement.",
        "input": "",
        "output": "The maintain_users privilege is required to execute the alter group statement. This privilege allows you to modify the list of users associated with a group identifier (group_id). You can use this privilege to add or drop user identifiers from the user list associated with a group identifier. For example:\nalter group sales_clerks\n    add users (dannyh, helent);\nThis statement adds the specified user_ids to the list of users associated with the sales_clerks group identifier. The user_ids must exist in order for them to be added to the group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids. If a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.",
        "taxonomy_path": "knowledge->programming_languages->sql_actian_4gl->alter_group",
        "task_description": "Learn about the syntax of Actian 4GL SQL alter group statements.",
        "document": [
            "Alter Group Statement\nThe alter group statement modifies the list of users associated with a group identifier. Individual users can be added or dropped or the entire list can be dropped.\nAn add and a drop operation cannot be performed in the same alter group statement.\nThis statement has the following syntax:\nalter group group_id {, group_id}\nadd users (user_id {, user_id}) | drop users (user_id {, user_id}) | drop all;\nParameters--Alter Group Statement\nThis statement has the following parameters:\nalter group group_id {, group_id}\nModifies the list of users associated with a group identifier (group_id).\nThe group_id must be an existing group identifier. If a non-existent group_id is specified, a warning is issued and processing continues with the next valid group_id in the list.\nadd users (user_id {, user_id})\nAdds the specified user_ids to the specified the group_ids.\nThe user_ids must exist to be added to a group. If a specified user_id does not exist, an error is issued and processing continues with the remaining user_ids.\nIf a specific user_id occurs more than once in the user list, additional occurrences of the specified user_id are ignored. No errors are issued.\ndrop users (user_id {, user_id})\nRemoves the specified user_ids to the specified the group_ids.\nIf a specified user_id is not in the group user list, an error is issued and processing continues with the remaining user_ids.\nA user cannot be dropped from a group if that group is the default group of the user. Use the alter user statement to change a user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\ndrop all\nRemoves all users from the specified group_ids.\nIf any member of the specified group has that group as its default group, drop all results in an error. Use the alter user statement to change the user's default group.\nIf a user is dropped from a group in a session that is associated with that group, the user retains the privileges of the group until the session terminates.\nPermissions\nMaintain_users privilege is required to execute the alter group statement.\nLocking\nThe alter group statement locks pages in the iiusergroup catalog in the iidbdb. This causes sessions attempting to connect to the server to be suspended until the alter group statement is completed.\nRelated Statements\nCreate Group Statement\nDrop Group Statement\nExamples--Alter Group Statement\nThe following examples add and drop user identifiers from the user list associated with a group identifier:\n1.Add users to the group, sales_clerks.\nalter group sales_clerks\n    add users (dannyh, helent);\n2.Drop three users from the group, tel_sales.\nalter group tel_sales\n    drop users (harryk, joanb, elainet);\n3.In an application, drop all users from the group, researchers.\nalter group researchers drop all;"
        ]
    }
]