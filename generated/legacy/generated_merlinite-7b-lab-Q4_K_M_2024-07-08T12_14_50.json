[
    {
        "instruction": "Explain abstract data types in OpenROAD programming language.",
        "input": "",
        "output": "Abstract data types in OpenROAD are special types of data that have specific characteristics and behavior. The three abstract data types discussed in the document are:\n1. Money data type: Represents monetary values with two decimal places. It can be specified as a character string literal or a number, and is rounded to dollars and cents on input and output. Money variables can accommodate a range of -999,999,999,999.99 to 999,999,999,999.99.\n2. Numeric string data type: A virtual type that exists when numeric and character data types are compared directly. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric.\n3. Logical key data type: Allows the DBMS Server or your application to assign a unique key value to each row in a table. Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. There are two types of logical keys: system-maintained and not system-maintained. Specify the scope of uniqueness for system-maintained logical key columns using TABLE\\_KEY or OBJECT\\_KEY options.\n\nPlease note that this response is based on the provided document, which focuses on abstract data types in the OpenROAD programming language. The examples and restrictions shown in the task instructions are not included in this response because they do not correspond to the information given in the document.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain the money data type in OpenROAD.",
        "input": "",
        "output": "The money data type is an abstract data type that stores values significant to two decimal places. It can accommodate a range of values from -$9,999,999,999.99 to $9,999,999,999.99 in the format $sdddddddddddd.dd.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe the logical key data type in OpenROAD.",
        "input": "",
        "output": "The logical key data type allows a unique key value to be assigned to each row in a table when an application requires it, and the columns of the table do not comprise a unique key. There are two types: system-maintained and not system-maintained.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain the numeric string data type in OpenROAD.",
        "input": "",
        "output": "The numeric string data type is a virtual type that exists only when numeric data types are compared directly with character data. It allows comparing character data as though both were numeric, and ignores leading and trailing spaces during conversion. Numbers are converted using float8 precision. The data types considered numeric include all integer types, all float types, and decimal.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain the logical key data type in OpenROAD.",
        "input": "",
        "output": "The logical key data type allows assigning a unique key value to each row in a table. It can be system maintained or not, and can have scope of uniqueness set to TABLE_KEY or OBJECT_KEY. System-maintained logical keys are returned as 8-byte strings for TABLE_KEY values and 16-byte strings for OBJECT_KEY values.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can logical keys be assigned to tables that do not have a unique key?",
        "input": "",
        "output": "Logical keys can be assigned to tables that do not have a unique key by using the logical key data type. Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. There are two types of logical keys: system-maintained and not system-maintained. System-maintained logical keys must be passed as type BYTE in a UTF-8 environment.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What restrictions apply to the use of logical keys in OpenROAD?",
        "input": "",
        "output": "When working with logical keys, be aware of the following restrictions:\n- A system\\_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not system\\_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system\\_maintained column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can a system-maintained logical key column be used in OpenROAD?",
        "input": "",
        "output": "A system-maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. Instead, it must be specified when creating the table, as shown in this example:\n\n```sql\nCREATE TABLE mytable (\n    id SYSTEM_MAINTAINED TABLE_KEY NOT NULL,\n    name VARCHAR(255) NOT NULL,\n    age INTEGER NOT NULL\n);\n```",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What does a money value look like when displayed in OpenROAD?",
        "input": "",
        "output": "A money value is displayed as a string of 20 characters with two decimal places, and it looks like this: $[-]dddddddddddd.dd where $ is the currency symbol and d is a digit from 0 to 9.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can money values be specified in OpenROAD?",
        "input": "",
        "output": "Money values can be specified as either a character string literal or a number. When specifying a money value as a character string literal, the format for input is $sdddddddddddd.dd. The dollar sign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value of zero (.00). When specifying a money value as a number, it is converted to the money data type automatically.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain how abstract data types are used in OpenROAD.",
        "input": "",
        "output": "Abstract data types represent specific types of data, such as Money, Numeric String, and Logical. They are used in OpenROAD to define data types and enable comparisons between numeric and character data. Abstract data types can also specify the range of values that a data type can accommodate. For example, the money data type is stored significant to two decimal places and can accommodate values within the range of -999,999,999,999.99 to 999,999,999,999.99 dollars or other currency units on input and output.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the format of logical key values in OpenROAD?",
        "input": "",
        "output": "In a UTF-8 environment, logical keys must be passed as type BYTE. For example:\n\n```sql\nINSERT INTO mytable(id_column) VALUES('12345678');\n```",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the purpose of logical key columns in OpenROAD?",
        "input": "",
        "output": "Logical key columns allow the DBMS Server or your application to assign a unique key value to each row in a table. They are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe the money data type in OpenROAD.",
        "input": "",
        "output": "The money data type in OpenROAD stores values significant to two decimal places and retains two-decimal-place precision for arithmetic operations. Money variables can accommodate a range of values from $-999,999,999,999.99 to $999,999,999,999.99 with a default precision of two decimal places. On output, money values display as strings of 20 characters.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain the numerical string data type in OpenROAD.",
        "input": "",
        "output": "The numerical string data type in OpenROAD is a virtual type that exists only when numeric data types are compared directly with character data. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How does OpenROAD handle logical keys?",
        "input": "",
        "output": "OpenROAD handles logical keys by allowing the DBMS Server or your application to assign a unique key value to each row in a table when an application requires it, and the columns of the table do not comprise a unique key. There are two types: system-maintained and not system-maintained.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What restrictions apply to logical keys?",
        "input": "",
        "output": "When working with logical keys, be aware of the following restrictions:\n1. A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not system_maintained data type is assigned to the resulting column.\n2. The COPY statement cannot be used to load values from a file into a system_maintained column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What can you do with money variables in OpenROAD?",
        "input": "",
        "output": "Money variables can accommodate the range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either a character string literal or a number. When specifying a money value as a character string literal, the format for input is $sdddddddddddd.dd. The dollar sign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value of zero (.00). When specifying a money value as a number, it is converted to the money data type automatically.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can logical keys be used in OpenROAD?",
        "input": "",
        "output": "Logical keys allow the DBMS Server or your application to assign a unique key value to each row in a table. Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. There are two types of logical keys:\n1. SYSTEM\\_MAINTAINED\n2. NOT SYSTEM\\_MAINTAINED\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE\\_KEY: Values are unique within the table.\n- OBJECT\\_KEY: Values are unique within the database.\nTABLE\\_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT\\_KEY values as 16-byte strings.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how to assign unique key values to each row in a table using logical keys.",
        "input": "",
        "output": "Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. Specify the scope of uniqueness for system-maintained logical key columns using the following options: TABLE_KEY values are unique within the table, and OBJECT_KEY values are unique within the database. For example:\n\n```sql\nINSERT INTO mytable(id_column) VALUES('12345678'); -- Assigns a unique value to the row\n```",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are logical key data types and why should you care about them?",
        "input": "",
        "output": "Logical key data types are used to assign unique keys to each row in a table, especially when the columns of the table do not comprise a unique key. They come in two flavors: system maintained and not system maintained. System maintained logical keys have their scope of uniqueness specified as TABLE_KEY or OBJECT_KEY, and they return 8-byte strings for TABLE_KEY values and 16-byte strings for OBJECT_KEY values. Values can be assigned to logical keys that are not system managed using string literals. When working with logical keys, there are some restrictions to keep in mind: a system\\_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement, and the COPY statement cannot be used to load values from a file into a system\\_maintained column. Logical key data types can help ensure data integrity and consistency in your database.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how the money data type is stored and displayed in OpenROAD.",
        "input": "",
        "output": "The money data type is stored with significant to two decimal places and rounded when input or output. Arithmetic operations on the money data type retain two-decimal-place precision. On output, money values display as strings of 20 characters with a default precision of two decimal places, in the format: $[-]dddddddddddd.dd where $ is the currency symbol and d is a digit from 0 to 9.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain how a money value can be specified as either a character string literal or a number in OpenROAD.",
        "input": "",
        "output": "A money value can be specified as either a character string literal or a number in OpenROAD. If it is specified as a character string literal, the format for character string input of a money value is $sdddddddddddd.dd where s is an optional currency symbol and d is a digit from 0 to 9. The dollar sign defaults to + if not specified, and the leading minus sign is allowed. If it is specified as a number, any valid integer or floating point number is acceptable; the number is converted to the money data type automatically.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how money values are compared with character data when OpenROAD encounters a comparison between these two classes of data.",
        "input": "",
        "output": "When OpenROAD encounters a comparison between numeric and character data, it checks the character data for numeric content. If the character data is numeric in form, then the comparison is performed as though both were numeric. Otherwise, all numbers collate before all non-numbers. The money data type is not treated in this manner because it has its own character data compatibility.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain how logical keys in OpenROAD can be assigned values using string literals.",
        "input": "",
        "output": "In OpenROAD, values can be assigned to TABLE_KEYs that are not system maintained using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can the scope of uniqueness for logical keys be specified in OpenROAD?",
        "input": "",
        "output": "In OpenROAD, the scope of uniqueness for system maintained logical key columns can be specified using:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are some of the limitations and restrictions that you should be aware of when working with logical keys?",
        "input": "",
        "output": "There are several limitations and restrictions to keep in mind when working with logical keys:\n- A system\\_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not system\\_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system\\_maintained column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are the specifications for money values in OpenROAD?",
        "input": "",
        "output": "Money values display as strings of 20 characters with a default precision of two decimal places. The display format is:\n$[-]dddddddddddd.dd\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data in OpenROAD:\n1. II\\_MONEY\\_FORMAT: Specifies the character displayed as the currency symbol\n2. II\\_MONEY\\_PREC: Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2\n3. II\\_DECIMAL: Specifies the character displayed as the decimal point\n\nNote that if II\\_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list of table columns or SQL functions with several parameters), that the comma is followed by a space. For other statements used in OpenROAD, use II\\_4GL\\_DECIMAL.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Given a money value of $-90, how would it be specified as either a character string literal or a number?",
        "input": "",
        "output": "A money value of $-90 can be specified in two ways:\n1. As a character string literal, the format for specifying money values is $sdddddddddddd.dd. In this case, the value would be: `-$90`\n2. As a number, any valid integer or floating point number is acceptable. The number can be converted to the money data type automatically. In this case, the value would be: `-90`",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Given the display format of money values in OpenROAD, what are the characters that indicate the currency symbol and decimal point?",
        "input": "",
        "output": "The characters that indicate the currency symbol in the display format of money values in OpenROAD is '$'. The character that indicates the decimal point is '.'",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How does the precision of arithmetic operations on the money data type in OpenROAD?",
        "input": "",
        "output": "Arithmetic operations on the money data type in OpenROAD retain two-decimal-place precision. Money values are stored significant to two decimal places and rounded accordingly.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How does the money data type handle arithmetic operations in OpenROAD?",
        "input": "",
        "output": "Arithmetic operations on the money data type retain two-decimal-place precision.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are the settings that affect the display of money values in OpenROAD?",
        "input": "",
        "output": "The following environment settings affect the display of money values: II_MONEY_FORMAT, II_MONEY_PREC, and II_DECIMAL.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe the Numeric String data type in OpenROAD.",
        "input": "",
        "output": "The numeric string data type is a virtual type that exists only when numeric data types are compared directly with character data. It allows comparing character data as though both were numeric, and ignores leading and trailing spaces during conversion. The data types considered as numeric include all integer types, all float types, and decimal.\n\nNumeric conversions are performed using float8 precision. When a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are some restrictions on using logical keys in OpenROAD?",
        "input": "",
        "output": "There are several restrictions to be aware of when working with logical keys in OpenROAD:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column instead.\n- The COPY statement cannot be used to load values from a file into a system_maintained logical key column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can money values be rounded in OpenROAD?",
        "input": "",
        "output": "Money values are stored significant to two decimal places in OpenROAD and arithmetic operations retain two-decimal-place precision. Money variables can accommodate the range of values from $-999,999,999,999.99 to $999,999,999,999.99. Money values display as strings of 20 characters with a default precision of two decimal places.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Give an example of how money values are displayed in OpenROAD.",
        "input": "",
        "output": "Money values display as strings of 20 characters with a default precision of two decimal places. For example, the money value $123.45 displays as '$123.45'.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the range of valid money values in OpenROAD?",
        "input": "",
        "output": "Money values can accommodate the range of values from -$9,999,999,999.99 to $9,999,999,999.99. Money variables can be specified as either a character string literal or a number. Any valid integer or floating point number is acceptable for a number; the number is converted to the money data type automatically.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain the concept of money data type in OpenROAD and its usage within the system.",
        "input": "",
        "output": "The money data type in OpenROAD is an abstract data type used to store monetary values with significant to two decimal places. It is rounded when input or output, and arithmetic operations on the money data type retain two-decimal-place precision. Money variables can accommodate values within the range of -999,999,999,999.99 to 999,999,999,999.99 dollars or other currency units on input and output. The money data type displays as a string of 20 characters with a default precision of two decimal places in the format: $[-]dddddddddddd.dd where $ is the currency symbol and d is a digit from 0 to 9.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how abstract data types are used in OpenROAD to enable comparisons between numeric and character data.",
        "input": "",
        "output": "Abstract data types in OpenROAD enable comparisons between numeric and character data by examining the character data to see if it is numeric in form when a comparison is requested between these two classes of data. If the character data is numeric, the comparison is performed as though both were numeric. If the data is not numeric, the result will be such that all numbers collate before all non-numbers. The numeric conversion is performed using float8 precision and leading and trailing spaces are ignored. The data types considered as numeric are all the integer types, all the float types, and decimal. Money is not treated in this manner because it has its own character data compatibility.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can numerical strings be converted in OpenROAD?",
        "input": "",
        "output": "Numeric strings can be converted in OpenROAD using float8 precision and leading and trailing spaces are ignored. To determine if a character data value is numeric, it must contain only one number which can be in integer, decimal, float, or scientific notation form.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain what a logical key is and how it can be assigned values in OpenROAD.",
        "input": "",
        "output": "A logical key is a unique key value that can be assigned to each row in a table. It allows the DBMS Server or your application to ensure a unique key for each row, even if the columns of the table do not comprise a unique key. Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key.\n\nIn OpenROAD, values can be assigned to TABLE\\_KEYs that are not system maintained using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain how the numeric string data type works in OpenROAD.",
        "input": "",
        "output": "The numeric string data type is a virtual type that exists only when numeric data types are compared directly with character data. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is a logical key data type?",
        "input": "",
        "output": "The logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a table. Logical keys are useful when an application requires a table to have a unique key and the columns of the table do not comprise a unique key.\n\nThere are two types of logical keys: SYSTEM\\_MAINTAINED and NOT\\_SYSTEM\\_MAINTAINED. System maintained logical keys values are unique within the table or object, and they can be returned as 8-byte or 16-byte strings for system\\_maintained or not\\_system\\_maintained types, respectively.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the difference between Money data type and Numeric string data type?",
        "input": "",
        "output": "Money data type represents monetary values with two decimal places and can be specified as a character string literal or a number. It is rounded to dollars and cents on input and output. Money variables can accommodate a range of -999,999,999,999.99 to 999,999,999,999.99. Numeric string data type, on the other hand, is a virtual type that exists only when numeric and character data types are compared directly with each other. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are the restrictions on Logical key?",
        "input": "",
        "output": "Logical keys have some restrictions when working with them. For example, a system-maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not system-maintained data type is assigned to the resulting column instead. Also, the COPY statement cannot be used to load values from a file into a system-maintained column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe the numeric string data type and how it affects the comparison between character data and numeric data types in OpenROAD.",
        "input": "",
        "output": "The numeric string data type is a virtual type that exists only when numeric data types are compared directly with character data. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not numeric, the result will be such that all numbers collate before",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are the effects of setting II\\_MONEY\\_FORMAT?",
        "input": "",
        "output": "When you set II\\_MONEY\\_FORMAT, you specify the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II\\_MONEY\\_FORMAT also specifies whether the symbol appears before of after the amount. When SQL statements within OpenROAD require a comma (such as a list of table columns or SQL functions with several parameters), that the comma is followed by a space. For other statements used in OpenROAD, use II\\_4GL\\_DECIMAL.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How are logical keys and money values displayed in OpenROAD?",
        "input": "",
        "output": "On output, money values display as strings of 20 characters with a default precision of two decimal places. The format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe display format for logical keys is not specified in the document. However, it can be inferred that the logical key value will be displayed as text, and its length will depend on the type of logical key (SYSTEM\\_MAINTAINED or NOT SYSTEM\\_MAINTAINED). The scope of uniqueness for system maintained logical key columns can be TABLE\\_KEY or OBJECT\\_KEY.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how logical keys are used for table uniqueness in OpenROAD.",
        "input": "",
        "output": "Logical keys allow the DBMS Server or your application to assign a unique key value to each row in a table. Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. There are two types of logical keys: SYSTEM\\_MAINTAINED and NOT SYSTEM\\_MAINTAINED. Specify the scope of uniqueness for system maintained logical key columns using the following options:\n1. TABLE\\_KEY: Values are unique within the table.\n2. OBJECT\\_KEY: Values are unique within the database.\nTABLE\\_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT\\_KEY values as 16-byte strings.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Discuss the restrictions on logical keys in OpenROAD.",
        "input": "",
        "output": "When working with logical keys, be aware of the following restrictions:\nA system\\_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not system\\_maintained data type is assigned to the resulting column. The COPY statement also cannot be used to load values from a file into a system\\_maintained column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are the different types of logical keys available in OpenROAD?",
        "input": "",
        "output": "OpenROAD provides two types of logical keys: SYSTEM_MAINTAINED and NOT SYSTEM_MAINTAINED. For system-maintained logical key columns, values can be unique within the table or object (database). System-maintained logical keys must have 8 or 16 byte string length when returned to embedded SQL programs as BYTE types. For not system-maintained logical keys, values are assigned to using string literals.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Can you provide some examples of the use cases for logical keys in OpenROAD?",
        "input": "",
        "output": "Logical keys can be useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. Logical keys allow the DBMS Server or your application to assign a unique key value to each row in a table. This is useful when you want to perform operations based on a specific set of rows.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe the behavior of the numeric string data type when comparing it directly with character data.",
        "input": "",
        "output": "When comparing the numeric string data type directly with character data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not numeric, the result will be such that all numbers collate before all non-numbers. The numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how the logical key data type can help ensure a table has a unique key when its columns do not comprise a unique key.",
        "input": "",
        "output": "The logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a table, making it useful when an application requires a table to have a unique key and the columns of the table do not comprise a unique key. There are two types of logical keys: SYSTEM_MAINTAINED and NOT SYSTEM_MAINTAINED.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain how to define a system-maintained logical key column in OpenROAD.",
        "input": "",
        "output": "To define a system-maintained logical key column, use the NOT SYSTEM\\_MAINTAINED data type and specify the scope of uniqueness using the TABLE\\_KEY or OBJECT\\_KEY options. System-maintained logical keys must be returned as 8-byte strings for TABLE\\_KEY values and 16-byte strings for OBJECT\\_KEY values.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are some of the environment settings that affect the display of money data in OpenROAD?",
        "input": "",
        "output": "Some of the environment settings that affect the display of money data in OpenROAD include:\n1. II\\_MONEY\\_FORMAT, which specifies the character displayed as the currency symbol and affects how the currency sign is displayed before or after the amount\n2. II\\_MONEY\\_PREC, which specifies the number of digits displayed after the decimal point (valid settings are 0, 1, and 2)\n3. II\\_DECIMAL, which specifies the character displayed as the decimal point and affects how FLOAT, FLOAT4, and DECIMAL data types are displayed",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the numeric conversion used for the character data to be deemed numeric in OpenROAD?",
        "input": "",
        "output": "The numeric conversion used for the character data to be deemed numeric in OpenROAD is performed using float8 precision.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe the restrictions on logical keys in OpenROAD.",
        "input": "",
        "output": "When working with logical keys, be aware of the following restrictions:\n- A system\\_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not system\\_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system\\_maintained column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain how money values are displayed as strings of 20 characters with a default precision of two decimal places in OpenROAD.",
        "input": "",
        "output": "Money values display as strings of 20 characters with a default precision of two decimal places in OpenROAD. The display format is: $[-]dddddddddddd.dd where $ is the default currency symbol and d is a digit from 0 to 9. II\\_MONEY\\_FORMAT specifies the character displayed as the currency symbol. If II\\_MONEY\\_FORMAT is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list of table columns or SQL functions with several parameters), that the comma is followed by a space.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can character data be examined in OpenROAD for numeric compatibility?",
        "input": "",
        "output": "Character data values are examined in OpenROAD to see if they are numeric in form by checking if it contains only one number, which can be in integer, decimal, float, or scientific notation form. All the character data types are checked for numeric content except the long variants, which are treated as non-numeric.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What data types are considered as numeric by OpenROAD?",
        "input": "",
        "output": "All the integer data types, all the float types, and decimal are considered as numeric by OpenROAD. Money is not treated in this manner because it has its own character data compatibility.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can numerical data types be compared directly with character data in OpenROAD?",
        "input": "",
        "output": "If a comparison is requested between numeric data and character data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not numeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are the environment settings that affect the display of money data?",
        "input": "",
        "output": "The following environment settings affect the display of money data in OpenROAD:\n- II_MONEY_FORMAT: Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before or after the amount.\n- II_MONEY_PREC: Specifies the number of digits displayed after the decimal point. Valid settings are 0, 1, and 2.\n- II_DECIMAL: Specifies the character displayed as the decimal point. The default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and DECIMAL data types.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain the compatibility of money and logical key abstract data types.",
        "input": "",
        "output": "Money is not treated in a manner compatible with logical key abstract data types because it has its own character data compatibility. Money values are stored significant to two decimal places and are rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic operations on the money data type retain two-decimal-place precision.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the purpose of using virtual types, such as numeric string data type?",
        "input": "",
        "output": "Virtual types, such as numeric string data type, exist only when numeric and character data types are compared directly. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not numeric, the result will be such that all numbers collate before all non-numbers.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How does OpenROAD compare character and numeric data types?",
        "input": "",
        "output": "OpenROAD compares character and numeric data types by examining the character data to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not numeric, the result will be such that all numbers collate before all non-numbers.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How are Money values stored in OpenROAD?",
        "input": "",
        "output": "Money values are stored significant to two decimal places.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the format for character string input of a money value in OpenROAD?",
        "input": "",
        "output": "The format for character string input of a money value is $sdddddddddddd.dd.\n* Task",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "List the columns of a table that have numeric compatibility.",
        "input": "",
        "output": "The numeric string data type allows the DBMS Server or your application to assign a unique key value to each row in a table. If a comparison is requested between character data and numeric data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. The data types considered as numeric are all the integer types, all the float types, and decimal.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe the compatibility of numeric string and logical key abstract data types.",
        "input": "",
        "output": "The logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a table. Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. There are two types of logical keys: SYSTEM_MAINTAINED and NOT SYSTEM_MAINTAINED. Specify the scope of uniqueness for system maintained logical key columns using the following options: TABLE\\_KEY or OBJECT\\_KEY. VALUES must be 8-byte strings (TABLE\\_KEY) or 16-byte strings (OBJECT\\_KEY).",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Give an example of how money data type is stored significantly to two decimal places.",
        "input": "",
        "output": "Money values are stored significant to two decimal places in OpenROAD. For instance, consider a money value like $100.00. The underlying numerical representation of this value is 100.00, where the hundred and the cent components each have a precision of one place. The hundredth component is rounded to the nearest whole dollar, so its numerical representation is 1.0, and the thousandth component is discarded because it is less than $0.01. Similarly, if the value were $256.37, the numerical representation would be 256.37, where the hundredth component is rounded to the nearest whole cent, resulting in a value of 256.37.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are the valid ranges for money data type?",
        "input": "",
        "output": "The valid ranges for money data type are:\n- Minimum amount: $-999,999,999,999.99\n- Maximum amount: $999,999,999,999.99\n\nMoney values outside this range cannot be represented in OpenROAD. For example, a money value like -$1e+06 or +$1e+06 would cause an error because they exceed the maximum valid amount.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How are logical keys defined and used for data type compatibility checks in OpenROAD?",
        "input": "",
        "output": "Logical keys play a role in data type compatibility checks by allowing the DBMS Server or your application to check if two types of data are comparable. If one of them is character data, it is checked for numeric content. If both types are character data, the character data with the higher precedence is treated as numeric. Logical keys help in making these comparisons more intuitive and accurate.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can a logical key column be assigned to system-maintained logical keys?",
        "input": "",
        "output": "System-maintained logical key columns cannot be created using the CREATE TABLE...AS SELECT statement. Instead, they must be specified when creating the table. This ensures that the logical key column is defined as a system-maintained logical key and can be assigned to system-maintained logical keys.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Why is it important to understand the different types of abstract data types and their characteristics in OpenROAD?",
        "input": "",
        "output": "Understanding the different types of abstract data types, such as money, numeric string, and logical key, is essential for effective database design and management. Each type has unique features and behavior that affect how data is stored, processed, and compared. For instance, money data types are stored with significant precision to two decimal places and retain this precision when performing arithmetic operations. Numeric string data types are checked for numeric content during compatibility checks and help ensure accurate comparisons. Logical key data types allow the assignment of unique keys to each row in a table, providing another level of consistency and integrity. By understanding these characteristics, developers can optimize their code and prevent potential issues down the line.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How are abstract data types used to ensure compatibility and consistency in OpenROAD?",
        "input": "",
        "output": "Abstract data types play a crucial role in ensuring compatibility and consistency in OpenROAD by providing clear guidelines for how data is stored, processed, and compared. For example, money data types have significant precision of two decimal places, which ensures accurate financial calculations. Numeric string data types are checked for numeric content during comparisons, leading to more intuitive and correct comparisons between different types of data. Logical key data types help ensure each row in a table has a unique identifier, contributing to overall data integrity. By understanding and leveraging these abstract data types, developers can build robust and reliable applications.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How does the OpenROAD programming language treat money data type?",
        "input": "",
        "output": "In OpenROAD, money values are stored with significant to two decimal places and arithmetic operations on the money data type retain two-decimal-place precision. Money variables can accommodate the range of values from -$9,999,999,999.99 to $9,999,999,999.99. Money values display as strings of 20 characters with a default precision of two decimal places; the display format is: $[+-]dddddddddddd.dd\n\nwhere $ is the default currency sign and d is a digit from 0 to 9. Environment settings such as II\\_MONEY\\_FORMAT, II\\_MONEY\\_PREC, and II\\_DECIMAL affect the display of money data. For example, if II\\_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list of table columns or SQL functions with several parameters), that the comma is followed by a space.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are numeric string and logical key data types in OpenROAD?",
        "input": "",
        "output": "Numeric string data type is a virtual type that exists only when numeric data types are compared directly with character data. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric.\n\nLogical key data type allows the DBMS Server or your application to assign a unique key value to each row in a table. Logical keys are useful when an application requires a table to have a unique key and the columns of the table do not comprise a unique key. There are two types of logical keys: SYSTEM\\_MAINTAINED and NOT\\_SYSTEM\\_MAINTAINED.\n\nSystem maintained logical key column values are unique within the table or object and can be returned as 8-byte strings for TABLE\\_KEY system maintained or 16-byte strings for OBJECT\\_KEY system maintained types. System maintained logical keys cannot be created using the CREATE TABLE...AS SELECT statement and cannot be loaded using the COPY statement from a file into a system\\_maintained column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What does the numeric conversion of character data values into float8 precision involve?",
        "input": "",
        "output": "The numeric conversion of character data values into float8 precision involves examining the character data value to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not numeric, the result will be such that all numbers collate before all non-numbers.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How are leading and trailing spaces ignored during the numeric conversion process?",
        "input": "",
        "output": "Leading and trailing spaces are ignored during the numeric conversion process in OpenROAD. This means that character data values with leading or trailing spaces are converted into their numeric equivalent without regard to the presence of those spaces.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how to assign a unique key value to each row in a table using the logical key data type in OpenROAD.",
        "input": "",
        "output": "The logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a table. Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. There are two types of logical keys: SYSTEM_MAINTAINED and NOT SYSTEM_MAINTAINED. Specify the scope of uniqueness for system maintained logical key columns using the following options: TABLE_KEY or OBJECT_KEY.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can money data types be stored in OpenROAD?",
        "input": "",
        "output": "Money data types are stored significant to two decimal places in OpenROAD and are rounded to their amounts in dollars and cents or other currency units on input and output. They retain two-decimal-place precision for arithmetic operations. Money variables can accommodate the range of values from $-999,999,999,999.99 to $999,999,999,999.99 and are specified as either a character string literal or a number. On output, money values display as strings of 20 characters with a default precision of two decimal places using the format: $[+-]dddddddddddd.dd",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are numeric string data types used for in OpenROAD?",
        "input": "",
        "output": "Numeric string data types are used for comparing character data with numeric data directly when the character data is numeric in form. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Give an example of how abstract data types can be used to simplify the process of working with money values in OpenROAD.",
        "input": "",
        "output": "Abstract data types in OpenROAD can be used to simplify the process of working with money values by storing them significant to two decimal places. Money variables can accommodate the following range of values: $999,999,999,999.99 to $999,999,999,999.99. This simplifies the process of working with money values because they are stored in a standardized format that can be easily compared and manipulated.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how the money data type is used to store money values in OpenROAD.",
        "input": "",
        "output": "The money data type in OpenROAD stores money values significant to two decimal places. It allows for arithmetic operations to be performed on the money data type with two-decimal-place precision. Money variables can be specified as either a character string literal or a number, and they will be automatically converted to the money data type upon input. The output of money values displays as strings of 20 characters with a default precision of two decimal places.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain the concept of numeric string data type in OpenROAD and its purpose when comparing character data directly with numeric data types.",
        "input": "",
        "output": "The numeric string data type is a virtual type that exists only when numeric data types are compared directly with character data. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. The numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How does OpenROAD handle money values stored with significant to two decimal places?",
        "input": "",
        "output": "OpenROAD handles money values stored with significant to two decimal places by rounding them to their amounts in dollars and cents or other currency units on input and output. Arithmetic operations on the money data type retain two-decimal-place precision.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Can you provide some examples of the use cases for the numeric string data type in OpenROAD?",
        "input": "",
        "output": "The numeric string data type in OpenROAD is a virtual type that exists only when numeric data types are compared directly with character data. If a comparison is requested between these two classes of data, the character data is examined to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. The data types considered as numeric are all the integer types, all the float types, and decimal. To be deemed numeric, a character data value must contain only one number which can be in integer, decimal, float or scientific notation form.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can you assign values to logical keys that are NOT SYSTEM_MAINTAINED in OpenROAD?",
        "input": "",
        "output": "You can assign values to logical keys that are NOT SYSTEM_MAINTAINED in OpenROAD using string literals. For example:\n\n```sql\nINSERT INTO keytable(logical_key_column) VALUES('12345678');\n```",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What are the restrictions on working with logical keys in OpenROAD?",
        "input": "",
        "output": "When working with logical keys in OpenROAD, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What can be considered as valid for specifying Money values?",
        "input": "",
        "output": "Money values can be specified as either a character string literal or a number. The format for character string input of a money value is $sdddddddddddd.dd. The dollar sign is optional and the algebraic sign(s) defaults to + if not specified. For example, '1234567890.12', '-1234567890.12', and '+1234567890.12' are valid money values.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the range of Money data type?",
        "input": "",
        "output": "The range of Money data type is from -999,999,999,999.99 to 999,999,999,999.99. This means that the minimum value that can be represented by a money variable is -999,999,999,999.99 dollars and the maximum value is 999,999,999,999.99 dollars.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Describe how logical keys are used in OpenROAD for table uniqueness.",
        "input": "",
        "output": "Logical keys allow the DBMS Server or your application to assign a unique key value to each row in a table. Logical keys are useful when an application requires a table to have a unique key, and the columns of the table do not comprise a unique key. There are two types of logical keys: SYSTEM\\_MAINTAINED and NOT SYSTEM\\_MAINTAINED. Specify the scope of uniqueness for system maintained logical key columns using the following options:\n1. TABLE\\_KEY: Values are unique within the table.\n2. OBJECT\\_KEY: Values are unique within the database.\nTABLE\\_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT\\_KEY values as 16-byte strings.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How does OpenROAD use logical keys in data type compatibility checks?",
        "input": "",
        "output": "Logical keys are used for data type compatibility checks by allowing the DBMS Server or your application to compare two types of data. If one of them is character data, it is checked for numeric content. If both types are character data, the character data with the higher precedence is treated as numeric. Logical keys help in making these comparisons more intuitive and accurate.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "Explain how a comparison between a character data value and a numeric string value is performed in OpenROAD.",
        "input": "",
        "output": "A comparison between a character data value and a numeric string value is performed by examining the character data to see if it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not numeric, the result will be such that all numbers collate before all non-numbers. The numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "How can you create system-maintained logical keys?",
        "input": "",
        "output": "A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not system_maintained data type is assigned to the resulting column.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the format of money variables?",
        "input": "",
        "output": "Money variables can accommodate the following range of values: $-999,999,999,999.99 to $999,999,999,999.99 and are stored significant to two decimal places. These values are rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic operations on the money data type retain two-decimal-place precision.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the format of a money value when specified as a character string literal in OpenROAD?",
        "input": "",
        "output": "A money value when specified as a character string literal in OpenROAD is written using the format $sdddddddddddd.dd where:\n- The dollar sign ($) is optional and defaults to + if not specified.\n- d is a digit from 0 to 9.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    },
    {
        "instruction": "What is the format of numeric string values when comparing them with character data?",
        "input": "",
        "output": "Numeric string values are converted to float8 precision and leading and trailing spaces are ignored. The data types considered as numeric are all the integer types, all the float types, and decimal. Money is not treated in this manner because it has its own character data compatibility. To be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, or scientific notation form.",
        "taxonomy_path": "knowledge->programming_languages->openroad->language_guide->abstract_data_types",
        "task_description": "Explain abstract data types in OpenROAD programming language",
        "document": [
            "# Abstract Data Types\n\nAbstract data types include the following:\n- Money\n- Numeric string\n- Logical\n\n## Money Data Type\n\nThe money data type is an abstract data type. Money values are stored significant to two decimal places. These values \nare rounded to their amounts in dollars and cents or other currency units on input and output, and arithmetic \noperations on the money data type retain two-decimal-place precision.\n\nMoney variables can accommodate the following range of values:\n$-999,999,999,999.99 to $999,999,999,999.99\n\nA money value can be specified as either:\n- A character string literal\u2014The format for character string input of a money value is $sdddddddddddd.dd. The dollar \nsign is optional and the algebraic sign(s) defaults to + if not specified. There is no need to specify a cents value \nof zero (.00).\n- A number\u2014Any valid integer or floating point number is acceptable. The number is converted to the money data type \nautomatically.\n\nOn output, money values display as strings of 20 characters with a default precision of two decimal places. The \ndisplay format is:\n$[-]dddddddddddd.dd\n\nwhere:\n$ is the default currency symbol\nd is a digit from 0 to 9\n\nThe following environment settings affect the display of money data. For details, see the Workbench User Guide:\n\n| Variable | Description |\n|----------|-------------|\n| II_MONEY_FORMAT | Specifies the character displayed as the currency symbol. The default currency sign is the dollar sign ($). II_MONEY_FORMAT also specifies whether the symbol appears before of after the amount. |\n| II_MONEY_PREC | Specifies the number of digits displayed after the decimal point; valid settings are 0, 1, and 2. |\n| II_DECIMAL | Specifies the character displayed as the decimal point; the default decimal point character is a period (.). II_DECIMAL also affects FLOAT, FLOAT4, and the DECIMAL data types. |\n\nNote: If II_DECIMAL is set to comma, be sure that when SQL statements within OpenROAD require a comma (such as a list \nof table columns or SQL functions with several parameters), that the comma is followed by a space. For other \nstatements used in OpenROAD, use II_4GL_DECIMAL. For more information, see the Workbench User Guide. For example:\n\n```sql\nselect col1, ifnull(col2, 0), left(col4, 22) from t1;\n```\n\n## Numeric String Data Type\n\nThe numeric string data type is a virtual type that exists only when numeric data types are compared directly with \ncharacter data. If a comparison is requested between these two classes of data, the character data is examined to see \nif it is numeric in form. If it is, then the comparison is performed as though both were numeric. If the data is not \nnumeric, the result will be such that all numbers collate before all non-numbers. For example:\n\n\u2013100 < '-9' < '0.01' < 1 < '1.1e1' < 'one' < 'three' < 'two'\n\nThe numeric conversion is performed using float8 precision and leading and trailing spaces are ignored.\n\nThe data types considered as numeric are all the integer types, all the float types, and decimal. Money is not \ntreated in this manner because it has its own character data compatibility.\n\nTo be deemed numeric, a character data value must contain only one number, which can be in integer, decimal, float, \nor scientific notation form. All the character data types are checked for numeric content except the long variants, \nwhich are treated as non-numeric.\n\n## Logical Key Data Type\n\nThe logical key data type allows the DBMS Server or your application to assign a unique key value to each row in a \ntable. Logical keys are useful when an application requires a table to have a unique key, and the columns of the \ntable do not comprise a unique key.\n\nThere are two types of logical keys:\n1. SYSTEM_MAINTAINED\n2. NOT SYSTEM_MAINTAINED\n\nSpecify the scope of uniqueness for system maintained logical key columns using the following options:\n- TABLE_KEY: Values are unique within the table.\n- OBJECT_KEY: Values are unique within the database.\n\nTABLE_KEY values are returned to embedded SQL programs as 8-byte strings, and OBJECT_KEY values as 16-byte strings. \nValues can be assigned to logical keys that are NOT SYSTEM_MAINTAINED using string literals. For example:\n\n```sql\nINSERT INTO keytable(table_key_column) VALUES('12345678');\n```\n\nValues assigned to TABLE_KEYs must be 8-byte strings; values assigned to OBJECT_KEYs must be 16-byte strings.\n\nIn a UTF-8 environment, logical keys must be passed as type BYTE.\n\n### Restrictions on Logical Keys\n\nWhen working with logical keys, be aware of the following restrictions:\n- A system_maintained logical key column cannot be created using the CREATE TABLE...AS SELECT statement. A not \nsystem_maintained data type is assigned to the resulting column.\n- The COPY statement cannot be used to load values from a file into a system_maintained column."
        ]
    }
]